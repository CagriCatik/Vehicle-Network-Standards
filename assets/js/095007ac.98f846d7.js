"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[19182],{66796:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>l,frontMatter:()=>a,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"GLOSSARY/B","title":"B","description":"Bus Guardian","source":"@site/docs/GLOSSARY/B.md","sourceDirName":"GLOSSARY","slug":"/GLOSSARY/B","permalink":"/Vehicle-Network-Standards/docs/GLOSSARY/B","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/GLOSSARY/B.md","tags":[],"version":"current","frontMatter":{},"sidebar":"glossarySidebar","previous":{"title":"A","permalink":"/Vehicle-Network-Standards/docs/GLOSSARY/A"},"next":{"title":"C","permalink":"/Vehicle-Network-Standards/docs/GLOSSARY/C"}}');var i=t(74848),s=t(28453);const a={},d="B",o={},u=[{value:"Bus Guardian",id:"bus-guardian",level:2},{value:"Bitstuffing",id:"bitstuffing",level:2},{value:"Botschaftsz\xe4hler",id:"botschaftsz\xe4hler",level:2},{value:"BRS",id:"brs",level:2}];function h(e){const n={h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"b",children:"B"})}),"\n",(0,i.jsx)(n.h2,{id:"bus-guardian",children:"Bus Guardian"}),"\n",(0,i.jsx)(n.p,{children:"Bus Guardian ist eine Funktion im FlexRay-Kommunikationssystem, die aktiv die Integrit\xe4t und Zuverl\xe4ssigkeit der Datenkommunikation auf dem FlexRay-Bus \xfcberwacht, um potenzielle Fehler oder Anomalien zu erkennen und durch entsprechende Ma\xdfnahmen wie Blockieren fehlerhafter Nachrichten oder Ausl\xf6sen von Warnungen die Sicherheit und Funktionsf\xe4higkeit sicherzustellen."}),"\n",(0,i.jsx)(n.h2,{id:"bitstuffing",children:"Bitstuffing"}),"\n",(0,i.jsx)(n.p,{children:"Bitstuffing ist eine Methode zur Fehlererkennung und -korrektur in der Daten\xfcbertragung. Dabei werden spezielle Bits in die Daten eingef\xfcgt, um sicherzustellen, dass das empfangene Signal korrekt interpretiert wird. Dies geschieht durch das Einf\xfcgen zus\xe4tzlicher Bits, wenn eine bestimmte Bitfolge im Datenstrom auftritt, um zu verhindern, dass diese Bitfolge f\xe4lschlicherweise als Steuerzeichen interpretiert wird."}),"\n",(0,i.jsx)(n.h2,{id:"botschaftsz\xe4hler",children:"Botschaftsz\xe4hler"}),"\n",(0,i.jsx)(n.p,{children:"Ein Botschaftsz\xe4hler (engl. Message Counter) ist ein wichtiges Konzept bei der Buskommunikation, wie beispielsweise beim CAN-Bus (Controller Area Network). Der Botschaftsz\xe4hler dient dazu, doppelte oder verlorene Nachrichten zu erkennen und somit die Datenkonsistenz zu gew\xe4hrleisten. Jede Nachricht, die \xfcber den Bus gesendet wird, erh\xe4lt eine fortlaufende Nummer (den Botschaftsz\xe4hler). Der Empf\xe4nger kann anhand dieser Nummer erkennen, ob eine Nachricht doppelt empfangen wurde (gleiche Nummer wie zuvor) oder ob eine Nachricht verloren ging (es fehlt eine Nummer in der Reihenfolge). Durch den Botschaftsz\xe4hler k\xf6nnen Fehler erkannt und behoben werden, indem z.B. verlorene Nachrichten erneut angefordert werden. Dies erh\xf6ht die Integrit\xe4t und Zuverl\xe4ssigkeit der Datenkommunikation \xfcber den Bus erheblich. Der Botschaftsz\xe4hler ist besonders wichtig in sicherheitskritischen Systemen, wo eine korrekte Daten\xfcbertragung zwischen den verschiedenen Steuerger\xe4ten essentiell ist."}),"\n",(0,i.jsx)(n.h2,{id:"brs",children:"BRS"}),"\n",(0,i.jsx)(n.p,{children:"Bit Rate Switch"})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>d});var r=t(96540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);