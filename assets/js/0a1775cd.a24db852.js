"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[1979],{8601:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"CAN/CAN-FD/botschaftsformate","title":"Botschaftsformate","description":"Rahmenformate in CAN FD","source":"@site/docs/CAN/06_CAN-FD/03_botschaftsformate.md","sourceDirName":"CAN/06_CAN-FD","slug":"/CAN/CAN-FD/botschaftsformate","permalink":"/Vehicle-Network-Standards/docs/CAN/CAN-FD/botschaftsformate","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/CAN/06_CAN-FD/03_botschaftsformate.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"canSidebar","previous":{"title":"Vorteile und Konsequenzen","permalink":"/Vehicle-Network-Standards/docs/CAN/CAN-FD/vorteile-konsequenzen"},"next":{"title":"Details der CAN-FD Botschaft","permalink":"/Vehicle-Network-Standards/docs/CAN/CAN-FD/details-can-fd-botschaft"}}');var r=t(74848),s=t(28453);const o={},d="Botschaftsformate",a={},l=[{value:"Rahmenformate in CAN FD",id:"rahmenformate-in-can-fd",level:2},{value:"Fehlen des CAN FD Remote Frames",id:"fehlen-des-can-fd-remote-frames",level:2},{value:"Kompatibilit\xe4t mit bestehenden Protokollen",id:"kompatibilit\xe4t-mit-bestehenden-protokollen",level:2},{value:"Schlussfolgerung",id:"schlussfolgerung",level:2}];function h(e){const n={h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"botschaftsformate",children:"Botschaftsformate"})}),"\n",(0,r.jsx)(n.h2,{id:"rahmenformate-in-can-fd",children:"Rahmenformate in CAN FD"}),"\n",(0,r.jsx)(n.p,{children:"CAN FD unterst\xfctzt, \xe4hnlich wie das klassische CAN-Protokoll, zwei Arten von Datenrahmenformaten: Standard Frames und Extended Frames. Diese Formate sind entscheidend, um die Kompatibilit\xe4t mit bestehenden Automobilnetzwerkprotokollen zu gew\xe4hrleisten."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Standard Rahmenformat (11-Bit-Identifier)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Das Standard Rahmenformat in CAN FD verwendet einen 11-Bit-Identifier, \xe4hnlich wie das klassische CAN-Protokoll. Dieser k\xfcrzere Identifier wird typischerweise in Anwendungen verwendet, bei denen eine kleinere Anzahl von eindeutigen Identifikatoren ausreicht, was einen schnelleren Arbitrierungsprozess erm\xf6glicht."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Erweitertes Rahmenformat (29-Bit-Identifier)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Das erweiterte Rahmenformat verwendet einen 29-Bit-Identifier, der eine wesentlich gr\xf6\xdfere Anzahl eindeutiger Identifikatoren zul\xe4sst. Dies ist in komplexen Systemen von entscheidender Bedeutung, in denen zahlreiche Ger\xe4te eindeutig kommunizieren m\xfcssen. Das erweiterte Identifier-Format stellt sicher, dass Protokolle wie CANopen und SAE J1939 weiterhin effektiv mit CAN FD funktionieren, indem sie ihren gr\xf6\xdferen Bereich von Identifikatoren aufnehmen."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Das System mit zwei Rahmenformaten stellt sicher, dass CAN FD die R\xfcckw\xe4rtskompatibilit\xe4t mit bestehenden Systemen beibeh\xe4lt und gleichzeitig die erweiterten F\xe4higkeiten bietet, die moderne Automobilanwendungen erfordern."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"CAN-Netzwerk",src:t(20769).A+"",width:"1625",height:"647"})}),"\n",(0,r.jsx)(n.h2,{id:"fehlen-des-can-fd-remote-frames",children:"Fehlen des CAN FD Remote Frames"}),"\n",(0,r.jsx)(n.p,{children:"Ein bemerkenswerter Unterschied zwischen CAN FD und dem klassischen CAN-Protokoll ist das Fehlen eines spezifischen Formats f\xfcr Remote Frames in CAN FD. Im klassischen CAN-Protokoll werden Remote Frames verwendet, um die \xdcbertragung eines Datenrahmens mit demselben Identifier anzufordern."}),"\n",(0,r.jsx)(n.p,{children:"Im CAN FD:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Kein Spezifisches Remote Frame Format"}),": CAN FD f\xfchrt kein eigenes Format f\xfcr Remote Frames ein. Dies ist keine Einschr\xe4nkung, sondern eine bewusste Designentscheidung, die auf der Betriebseffizienz des Protokolls beruht."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Datenraten\xfcberlegungen"}),": Remote Frames tragen keine Datenmengen, und ihre Verwendung w\xfcrde nicht von den erh\xf6hten Datenraten profitieren, die CAN FD unterst\xfctzt. Daher w\xfcrde die Definition eines separaten Remote Frame Formats die Leistung nicht verbessern."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Kompatibilit\xe4t mit klassischem CAN"}),": CAN FD erm\xf6glicht die Verwendung klassischer CAN Remote Frames zur Anforderung von CAN FD Datenrahmen. Dies stellt sicher, dass Systeme, die auf CAN FD migrieren, weiterhin die vorhandene Remote Frame-Funktionalit\xe4t ohne \xc4nderungen nutzen k\xf6nnen."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"kompatibilit\xe4t-mit-bestehenden-protokollen",children:"Kompatibilit\xe4t mit bestehenden Protokollen"}),"\n",(0,r.jsx)(n.p,{children:"Das Design von CAN FD stellt sicher, dass bestehende Hochprotokolle wie CANopen und SAE J1939 weiterhin nahtlos mit den neuen Funktionen von CAN FD arbeiten k\xf6nnen."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CANopen"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"CANopen ist ein Kommunikationsprotokoll und eine Ger\xe4teprofilspezifikation f\xfcr eingebettete Systeme in der Automatisierung. Die F\xe4higkeit von CAN FD, gr\xf6\xdfere Datenmengen und schnellere Datenraten zu handhaben, kann CANopen-Anwendungen verbessern, insbesondere in Szenarien, die einen schnellen Datenaustausch und h\xf6here Bandbreiten erfordern."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"SAE J1939"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"SAE J1939 ist ein Hochprotokoll, das in Nutzfahrzeugen zur Kommunikation und Diagnose zwischen Fahrzeugkomponenten verwendet wird. Das erweiterte Identifier-Rahmenformat in CAN FD unterst\xfctzt den umfangreichen Identifier-Bereich, der von SAE J1939 ben\xf6tigt wird, und stellt sicher, dass es die erh\xf6hten Datenraten und gr\xf6\xdferen Datenmengen von CAN FD nutzen kann."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"schlussfolgerung",children:"Schlussfolgerung"}),"\n",(0,r.jsx)(n.p,{children:"CAN FD stellt einen bedeutenden Fortschritt gegen\xfcber dem klassischen CAN-Protokoll dar, indem es schnellere Daten\xfcbertragungsraten und die M\xf6glichkeit zur Handhabung gr\xf6\xdferer Datenmengen bietet. Durch die Beibehaltung der Standard- und erweiterten Rahmenformate stellt CAN FD die Kompatibilit\xe4t mit bestehenden Automobilprotokollen wie CANopen und SAE J1939 sicher. Die Entscheidung, kein spezifisches Remote Frame Format f\xfcr CAN FD einzuf\xfchren, ist eine bewusste Wahl, die den Leistungszielen des Protokolls entspricht, w\xe4hrend klassische CAN Remote Frames weiterhin zur Anforderung von CAN FD Datenrahmen verwendet werden k\xf6nnen."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},20769:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/1712277018285-c9edb1aa2bbf0860515cec4b1dccbf8a.png"},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var i=t(96540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);