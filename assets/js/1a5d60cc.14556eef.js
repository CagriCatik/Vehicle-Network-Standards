"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[9738],{99271:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"OTA/oem-backend-tcu/mqtt-connectivity","title":"MQTT Connectivity","description":"In the realm of modern automotive technologies, Over-the-Air (OTA) updates have revolutionized the way vehicles receive software enhancements, security patches, and new features. Central to the efficiency and reliability of OTA update mechanisms is the Message Queuing Telemetry Transport (MQTT) protocol. This documentation delves deep into MQTT connectivity within automotive OTA systems, elucidating the interaction between OEM backends, MQTT brokers, and Distributed Control Units (DCUs). Advanced users and industry professionals will gain comprehensive insights into the architecture, communication flows, and technical implementations that underpin secure and efficient OTA updates.","source":"@site/docs/OTA/05_oem-backend-tcu/02_mqtt-connectivity.md","sourceDirName":"OTA/05_oem-backend-tcu","slug":"/OTA/oem-backend-tcu/mqtt-connectivity","permalink":"/Vehicle-Network-Standards/docs/OTA/oem-backend-tcu/mqtt-connectivity","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/OTA/05_oem-backend-tcu/02_mqtt-connectivity.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"otaSidebar","previous":{"title":"MQTT","permalink":"/Vehicle-Network-Standards/docs/OTA/oem-backend-tcu/mqtt"},"next":{"title":"HTTP","permalink":"/Vehicle-Network-Standards/docs/OTA/oem-backend-tcu/https"}}');var i=s(74848),r=s(28453);const a={},c="MQTT Connectivity",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Architecture and Components",id:"architecture-and-components",level:2},{value:"Key Components",id:"key-components",level:3},{value:"Communication Flow",id:"communication-flow",level:3},{value:"MQTT Protocol Details",id:"mqtt-protocol-details",level:2},{value:"Publish/Subscribe Model",id:"publishsubscribe-model",level:3},{value:"Topics",id:"topics",level:3},{value:"Wildcards",id:"wildcards",level:4},{value:"Quality of Service (QoS) Levels",id:"quality-of-service-qos-levels",level:3},{value:"MQTT Connectivity Workflow in OTA Updates",id:"mqtt-connectivity-workflow-in-ota-updates",level:2},{value:"Step-by-Step Process",id:"step-by-step-process",level:3},{value:"Diagrammatic Representation",id:"diagrammatic-representation",level:3},{value:"Technical Implementations",id:"technical-implementations",level:2},{value:"1. <strong>Publishing Update Issue Details from OEM Backend</strong>",id:"1-publishing-update-issue-details-from-oem-backend",level:3},{value:"2. <strong>MQTT Broker Configuration</strong>",id:"2-mqtt-broker-configuration",level:3},{value:"3. <strong>DCU Subscription and Handling Update Status</strong>",id:"3-dcu-subscription-and-handling-update-status",level:3},{value:"4. <strong>Publishing Update Status from MQTT Broker to DCU</strong>",id:"4-publishing-update-status-from-mqtt-broker-to-dcu",level:3},{value:"5. <strong>Handling Update Progress from DCU</strong>",id:"5-handling-update-progress-from-dcu",level:3},{value:"6. <strong>Backend Subscription to Update Progress</strong>",id:"6-backend-subscription-to-update-progress",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"1. <strong>Data Encryption</strong>",id:"1-data-encryption",level:3},{value:"2. <strong>Authentication and Authorization</strong>",id:"2-authentication-and-authorization",level:3},{value:"3. <strong>Access Control</strong>",id:"3-access-control",level:3},{value:"4. <strong>Message Integrity</strong>",id:"4-message-integrity",level:3},{value:"5. <strong>Secure Boot Mechanisms</strong>",id:"5-secure-boot-mechanisms",level:3},{value:"Error Handling and Reliability",id:"error-handling-and-reliability",level:2},{value:"1. <strong>Handling Message Loss and Duplication</strong>",id:"1-handling-message-loss-and-duplication",level:3},{value:"2. <strong>Monitoring and Alerting</strong>",id:"2-monitoring-and-alerting",level:3},{value:"3. <strong>Rollback Mechanisms</strong>",id:"3-rollback-mechanisms",level:3},{value:"Best Practices for MQTT in Automotive OTA Updates",id:"best-practices-for-mqtt-in-automotive-ota-updates",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"mqtt-connectivity",children:"MQTT Connectivity"})}),"\n",(0,i.jsxs)(n.p,{children:["In the realm of modern automotive technologies, ",(0,i.jsx)(n.strong,{children:"Over-the-Air (OTA)"})," updates have revolutionized the way vehicles receive software enhancements, security patches, and new features. Central to the efficiency and reliability of OTA update mechanisms is the ",(0,i.jsx)(n.strong,{children:"Message Queuing Telemetry Transport (MQTT)"})," protocol. This documentation delves deep into MQTT connectivity within automotive OTA systems, elucidating the interaction between OEM backends, MQTT brokers, and Distributed Control Units (DCUs). Advanced users and industry professionals will gain comprehensive insights into the architecture, communication flows, and technical implementations that underpin secure and efficient OTA updates."]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"MQTT"})," is a lightweight, publish/subscribe-based messaging protocol designed for constrained environments with limited bandwidth and high latency. Its efficiency and scalability make it an ideal choice for automotive applications, where numerous Electronic Control Units (ECUs) require reliable communication for OTA updates. By facilitating seamless interaction between OEM backends, MQTT brokers, and DCUs, MQTT ensures that vehicles remain up-to-date with the latest software without necessitating physical interventions."]}),"\n",(0,i.jsx)(n.h2,{id:"architecture-and-components",children:"Architecture and Components"}),"\n",(0,i.jsx)(n.h3,{id:"key-components",children:"Key Components"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"OEM Backend:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Acts as the central repository for software updates, managing update packages, metadata, and deployment strategies."}),"\n",(0,i.jsx)(n.li,{children:"Interfaces with the MQTT broker to publish update notifications and receive acknowledgments from DCUs."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"MQTT Broker:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Serves as the intermediary that manages message distribution between publishers (OEM Backend) and subscribers (DCUs)."}),"\n",(0,i.jsx)(n.li,{children:"Ensures secure, reliable, and efficient transmission of messages based on MQTT protocols."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Distributed Control Units (DCUs):"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Embedded systems within vehicles responsible for managing various functions and executing OTA updates."}),"\n",(0,i.jsx)(n.li,{children:"Subscribed to specific MQTT topics to receive update notifications and status messages."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Electronic Control Units (ECUs):"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Individual modules within the vehicle that control specific systems (e.g., engine, transmission, infotainment)."}),"\n",(0,i.jsx)(n.li,{children:"Receive and install software updates as directed by DCUs."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"communication-flow",children:"Communication Flow"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Update Notification:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The OEM Backend identifies a new software update for a specific ECU."}),"\n",(0,i.jsxs)(n.li,{children:["It publishes an update notification to a designated MQTT topic (e.g., ",(0,i.jsx)(n.code,{children:"vehicle/updates/{VIN}/issue_details"}),")."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Broker Processing:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The MQTT Broker receives the update notification and verifies its validity."}),"\n",(0,i.jsx)(n.li,{children:"It checks for the availability and compatibility of the update with the target ECU."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Update Status Publication:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If a new update is available, the broker publishes the update status to another MQTT topic (e.g., ",(0,i.jsx)(n.code,{children:"vehicle/updates/{VIN}/status"}),")."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"DCU Reception and Acknowledgment:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The DCU, subscribed to the relevant topics, receives the update status."}),"\n",(0,i.jsx)(n.li,{children:"It verifies the update's integrity and authenticity with the OEM Backend."}),"\n",(0,i.jsx)(n.li,{children:"Upon successful verification, the DCU acknowledges the message and initiates the update process on the target ECU."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"mqtt-protocol-details",children:"MQTT Protocol Details"}),"\n",(0,i.jsx)(n.h3,{id:"publishsubscribe-model",children:"Publish/Subscribe Model"}),"\n",(0,i.jsxs)(n.p,{children:["MQTT operates on a ",(0,i.jsx)(n.strong,{children:"publish/subscribe"})," paradigm, which decouples message producers from consumers. This model enhances scalability and flexibility, allowing multiple DCUs to subscribe to update topics without requiring direct connections to the OEM Backend."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Publishers:"})," Entities (e.g., OEM Backend) that send messages to specific topics."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subscribers:"})," Entities (e.g., DCUs) that listen to specific topics to receive relevant messages."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Broker:"})," Manages the distribution of messages from publishers to subscribers based on topic subscriptions."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"topics",children:"Topics"}),"\n",(0,i.jsx)(n.p,{children:"Topics in MQTT are hierarchical strings that categorize messages, enabling selective subscription and message filtering."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Structure:"})," ",(0,i.jsx)(n.code,{children:"level1/level2/level3"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example:"})," ",(0,i.jsx)(n.code,{children:"vehicle/updates/{VIN}/issue_details"})]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"wildcards",children:"Wildcards"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Single-Level Wildcard (",(0,i.jsx)(n.code,{children:"+"}),"):"]})," Matches exactly one topic level.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example:"})," ",(0,i.jsx)(n.code,{children:"vehicle/updates/+/issue_details"})," matches ",(0,i.jsx)(n.code,{children:"vehicle/updates/VIN1234567890/issue_details"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Multi-Level Wildcard (",(0,i.jsx)(n.code,{children:"#"}),"):"]})," Matches any number of topic levels, including zero.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Example:"})," ",(0,i.jsx)(n.code,{children:"vehicle/#"})," matches all topics starting with ",(0,i.jsx)(n.code,{children:"vehicle/"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"quality-of-service-qos-levels",children:"Quality of Service (QoS) Levels"}),"\n",(0,i.jsx)(n.p,{children:"MQTT defines three QoS levels to balance message delivery guarantees against network efficiency:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"QoS 0: At Most Once (Fire and Forget)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," The message is delivered once with no acknowledgment. It may be lost if the client disconnects."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Case:"})," Non-critical messages where occasional loss is acceptable."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"QoS 1: At Least Once (Acknowledged Delivery)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Guarantees that the message is delivered at least once. The sender waits for an acknowledgment from the broker."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Case:"})," Critical messages where duplicates are acceptable, such as update notifications."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"QoS 2: Exactly Once (Assured Delivery)"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Description:"})," Ensures that the message is delivered exactly once by using a four-step handshake process."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Case:"})," Transactions where duplicates could cause inconsistencies, such as firmware installations."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["In automotive OTA systems, ",(0,i.jsx)(n.strong,{children:"QoS 1"})," is predominantly used to balance reliability and efficiency."]})}),"\n",(0,i.jsx)(n.h2,{id:"mqtt-connectivity-workflow-in-ota-updates",children:"MQTT Connectivity Workflow in OTA Updates"}),"\n",(0,i.jsx)(n.h3,{id:"step-by-step-process",children:"Step-by-Step Process"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Publishing Update Issue Details:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The OEM Backend identifies a new software update for a specific ECU."}),"\n",(0,i.jsxs)(n.li,{children:["It publishes the update issue details to the MQTT topic ",(0,i.jsx)(n.code,{children:"vehicle/updates/{VIN}/issue_details"})," with QoS 1."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Broker Verification and Status Publication:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The MQTT Broker receives the update issue details."}),"\n",(0,i.jsx)(n.li,{children:"It verifies the availability of the update with the backend."}),"\n",(0,i.jsxs)(n.li,{children:["If the update is available, the broker publishes the update status to ",(0,i.jsx)(n.code,{children:"vehicle/updates/{VIN}/status"})," with QoS 1."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"DCU Subscription and Acknowledgment:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The DCU, subscribed to ",(0,i.jsx)(n.code,{children:"vehicle/updates/{VIN}/status"}),", receives the update status message."]}),"\n",(0,i.jsx)(n.li,{children:"It verifies the update's authenticity and integrity with the backend."}),"\n",(0,i.jsx)(n.li,{children:"Upon successful verification, the DCU acknowledges the message and initiates the update process on the target ECU."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Feedback Loop:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The DCU publishes progress updates to ",(0,i.jsx)(n.code,{children:"vehicle/updates/{VIN}/progress"})," as the update proceeds."]}),"\n",(0,i.jsxs)(n.li,{children:["The OEM Backend subscribes to ",(0,i.jsx)(n.code,{children:"vehicle/updates/{VIN}/progress"})," to monitor update statuses."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"diagrammatic-representation",children:"Diagrammatic Representation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'OEM Backend\n    |\n    | Publishes to "vehicle/updates/{VIN}/issue_details" (QoS 1)\n    |\nMQTT Broker\n    |\n    | Verifies update availability\n    |\n    | Publishes to "vehicle/updates/{VIN}/status" (QoS 1)\n    |\nDCU (Subscriber)\n    |\n    | Acknowledges and initiates update\n    |\nTarget ECU\n    |\n    | Executes firmware update\n    |\nDCU\n    |\n    | Publishes to "vehicle/updates/{VIN}/progress" (QoS 1)\n    |\nMQTT Broker\n    |\n    | Forwards progress to OEM Backend\n    |\nOEM Backend (Subscriber)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"technical-implementations",children:"Technical Implementations"}),"\n",(0,i.jsx)(n.p,{children:"This section provides practical code examples demonstrating MQTT connectivity between the OEM Backend, MQTT Broker, and DCU within an automotive OTA update system."}),"\n",(0,i.jsxs)(n.h3,{id:"1-publishing-update-issue-details-from-oem-backend",children:["1. ",(0,i.jsx)(n.strong,{children:"Publishing Update Issue Details from OEM Backend"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Python example using ",(0,i.jsx)(n.code,{children:"paho-mqtt"})," library to publish update issue details."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\nimport json\n\ndef publish_update_issue(vin, version, description):\n    client = mqtt.Client()\n    client.username_pw_set("backend_user", "backend_password")\n    client.tls_set(ca_certs="path/to/ca.crt",\n                   certfile="path/to/backend.crt",\n                   keyfile="path/to/backend.key")\n    client.connect("mqtt.broker.address", 8883, 60)\n    \n    topic = f"vehicle/updates/{vin}/issue_details"\n    payload = {\n        "version": version,\n        "description": description\n    }\n    client.publish(topic, json.dumps(payload), qos=1)\n    client.disconnect()\n\n# Example usage\npublish_update_issue("VIN1234567890", "3.0.1", "Enhanced Autopilot features and security patches.")\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"2-mqtt-broker-configuration",children:["2. ",(0,i.jsx)(n.strong,{children:"MQTT Broker Configuration"})]}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.strong,{children:"Mosquitto"})," as the MQTT broker with secure configurations."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Installation and Setup:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Install Mosquitto on a Linux system\nsudo apt-get update\nsudo apt-get install mosquitto mosquitto-clients\n\n# Start Mosquitto service\nsudo systemctl start mosquitto\n\n# Enable Mosquitto to start on boot\nsudo systemctl enable mosquitto\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Secure Configuration (",(0,i.jsx)(n.code,{children:"mosquitto.conf"}),"):"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-conf",children:"# mosquitto.conf - Example secure configuration\n\nlistener 8883\ncafile /etc/mosquitto/certs/ca.crt\ncertfile /etc/mosquitto/certs/server.crt\nkeyfile /etc/mosquitto/certs/server.key\nrequire_certificate true\nuse_identity_as_username true\n\n# ACL Configuration\nacl_file /etc/mosquitto/acl.conf\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Access Control List (",(0,i.jsx)(n.code,{children:"acl.conf"}),"):"]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-conf",children:"# mosquitto.acl - Example ACL configuration\n\n# Backend User\nuser backend_user\ntopic write vehicle/updates/+/issue_details\ntopic read vehicle/updates/+/progress\ntopic read vehicle/updates/+/status\n\n# DCU User\nuser dcu_user\ntopic read vehicle/updates/+/issue_details\ntopic write vehicle/updates/{VIN}/progress\ntopic write vehicle/updates/{VIN}/status\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-dcu-subscription-and-handling-update-status",children:["3. ",(0,i.jsx)(n.strong,{children:"DCU Subscription and Handling Update Status"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Python example using ",(0,i.jsx)(n.code,{children:"paho-mqtt"})," library for DCU to subscribe to update status and acknowledge messages."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\nimport json\n\ndef on_connect(client, userdata, flags, rc):\n    print("DCU connected to MQTT broker with result code " + str(rc))\n    client.subscribe("vehicle/updates/VIN1234567890/status", qos=1)\n\ndef on_message(client, userdata, msg):\n    update_status = json.loads(msg.payload.decode())\n    print(f"Received update status: {update_status[\'status\']} for version {update_status[\'version\']}")\n    \n    # Verify update details with backend (pseudo-code)\n    if verify_update(update_status):\n        acknowledge_update(client, msg.topic, "Acknowledged")\n        initiate_firmware_update(update_status)\n    else:\n        print("Update verification failed.")\n\ndef verify_update(update_status):\n    # Implement verification logic (e.g., check digital signatures)\n    return True\n\ndef acknowledge_update(client, topic, acknowledgment):\n    ack_topic = topic + "/acknowledgment"\n    payload = {\n        "acknowledgment": acknowledgment\n    }\n    client.publish(ack_topic, json.dumps(payload), qos=1)\n    print("Acknowledgment sent.")\n\ndef initiate_firmware_update(update_status):\n    # Implement firmware update initiation logic\n    print(f"Initiating firmware update to version {update_status[\'version\']}.")\n\ndef dcu_mqtt_setup():\n    client = mqtt.Client()\n    client.username_pw_set("dcu_user", "dcu_password")\n    client.tls_set(cafile="path/to/ca.crt",\n                   certfile="path/to/dcu.crt",\n                   keyfile="path/to/dcu.key")\n    client.on_connect = on_connect\n    client.on_message = on_message\n    client.connect("mqtt.broker.address", 8883, 60)\n    client.loop_forever()\n\n# Example usage\ndcu_mqtt_setup()\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"4-publishing-update-status-from-mqtt-broker-to-dcu",children:["4. ",(0,i.jsx)(n.strong,{children:"Publishing Update Status from MQTT Broker to DCU"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Python example using ",(0,i.jsx)(n.code,{children:"paho-mqtt"})," library to simulate broker publishing update status."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\nimport json\nimport time\n\ndef publish_update_status(vin, status, version):\n    client = mqtt.Client()\n    client.username_pw_set("backend_user", "backend_password")\n    client.tls_set(ca_certs="path/to/ca.crt",\n                   certfile="path/to/backend.crt",\n                   keyfile="path/to/backend.key")\n    client.connect("mqtt.broker.address", 8883, 60)\n    \n    topic = f"vehicle/updates/{vin}/status"\n    payload = {\n        "status": status,\n        "version": version\n    }\n    client.publish(topic, json.dumps(payload), qos=1)\n    client.disconnect()\n\n# Example usage\ntime.sleep(5)  # Wait for DCU to subscribe\npublish_update_status("VIN1234567890", "Available", "3.0.1")\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"5-handling-update-progress-from-dcu",children:["5. ",(0,i.jsx)(n.strong,{children:"Handling Update Progress from DCU"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Python example using ",(0,i.jsx)(n.code,{children:"paho-mqtt"})," library for DCU to publish update progress."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\nimport json\nimport time\n\ndef publish_update_progress(vin, progress, status):\n    client = mqtt.Client()\n    client.username_pw_set("dcu_user", "dcu_password")\n    client.tls_set(cafile="path/to/ca.crt",\n                   certfile="path/to/dcu.crt",\n                   keyfile="path/to/dcu.key")\n    client.connect("mqtt.broker.address", 8883, 60)\n    \n    topic = f"vehicle/updates/{vin}/progress"\n    payload = {\n        "progress": progress,  # Percentage\n        "status": status       # e.g., "downloading", "installing"\n    }\n    client.publish(topic, json.dumps(payload), qos=1)\n    client.disconnect()\n\n# Example usage\nvin = "VIN1234567890"\nstatuses = ["downloading", "installing", "finalizing", "completed"]\nfor i, status in enumerate(statuses, start=25):\n    publish_update_progress(vin, i, status)\n    time.sleep(2)\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"6-backend-subscription-to-update-progress",children:["6. ",(0,i.jsx)(n.strong,{children:"Backend Subscription to Update Progress"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["Python example using ",(0,i.jsx)(n.code,{children:"paho-mqtt"})," library for backend to subscribe to update progress."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\nimport json\n\ndef on_connect(client, userdata, flags, rc):\n    print("Backend connected to MQTT broker with result code " + str(rc))\n    client.subscribe("vehicle/updates/VIN1234567890/progress", qos=1)\n\ndef on_message(client, userdata, msg):\n    progress_info = json.loads(msg.payload.decode())\n    print(f"Update Progress for VIN1234567890: {progress_info[\'progress\']}% - Status: {progress_info[\'status\']}")\n\ndef backend_mqtt_setup():\n    client = mqtt.Client()\n    client.username_pw_set("backend_user", "backend_password")\n    client.tls_set(cafile="path/to/ca.crt",\n                   certfile="path/to/backend.crt",\n                   keyfile="path/to/backend.key")\n    client.on_connect = on_connect\n    client.on_message = on_message\n    client.connect("mqtt.broker.address", 8883, 60)\n    client.loop_forever()\n\n# Example usage\nbackend_mqtt_setup()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.p,{children:"Ensuring the security of MQTT communications in automotive OTA update systems is paramount to prevent unauthorized access, data breaches, and malicious interventions. The following security measures should be implemented:"}),"\n",(0,i.jsxs)(n.h3,{id:"1-data-encryption",children:["1. ",(0,i.jsx)(n.strong,{children:"Data Encryption"})]}),"\n",(0,i.jsxs)(n.p,{children:["All MQTT communications must be encrypted using ",(0,i.jsx)(n.strong,{children:"TLS/SSL"})," to protect data integrity and confidentiality."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example: Enabling TLS/SSL in MQTT Clients"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\n\ndef connect_secure_mqtt(username, password, ca_certs, certfile, keyfile):\n    client = mqtt.Client()\n    client.username_pw_set(username, password)\n    client.tls_set(ca_certs=ca_certs,\n                   certfile=certfile,\n                   keyfile=keyfile)\n    client.connect("mqtt.secure.broker.address", 8883, 60)\n    return client\n\n# Example usage\nclient = connect_secure_mqtt("backend_user", "backend_password",\n                             "path/to/ca.crt",\n                             "path/to/backend.crt",\n                             "path/to/backend.key")\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"2-authentication-and-authorization",children:["2. ",(0,i.jsx)(n.strong,{children:"Authentication and Authorization"})]}),"\n",(0,i.jsx)(n.p,{children:"Implement robust authentication mechanisms, such as username/password authentication or certificate-based authentication, to ensure that only authorized clients can connect to the MQTT broker."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example: Username and Password Authentication"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\n\ndef connect_authenticated_mqtt(username, password):\n    client = mqtt.Client()\n    client.username_pw_set(username, password)\n    client.connect("mqtt.broker.address", 1883, 60)\n    return client\n\n# Example usage\nclient = connect_authenticated_mqtt("backend_user", "backend_password")\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"3-access-control",children:["3. ",(0,i.jsx)(n.strong,{children:"Access Control"})]}),"\n",(0,i.jsx)(n.p,{children:"Define strict access control policies on the MQTT broker to regulate which topics clients can publish or subscribe to, minimizing the risk of unauthorized data access or manipulation."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example: Mosquitto ACL Configuration"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-conf",children:"# mosquitto.acl - Example ACL configuration\n\n# Backend User\nuser backend_user\ntopic write vehicle/updates/+/issue_details\ntopic read vehicle/updates/+/progress\ntopic read vehicle/updates/+/status\n\n# DCU User\nuser dcu_user\ntopic read vehicle/updates/+/issue_details\ntopic write vehicle/updates/VIN1234567890/progress\ntopic write vehicle/updates/VIN1234567890/status\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-message-integrity",children:["4. ",(0,i.jsx)(n.strong,{children:"Message Integrity"})]}),"\n",(0,i.jsx)(n.p,{children:"Utilize message signing and verification to ensure that messages are not tampered with during transmission."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example: Message Signing Using HMAC"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import hmac\nimport hashlib\n\ndef sign_message(message, secret_key):\n    signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).hexdigest()\n    return signature\n\ndef verify_message(message, signature, secret_key):\n    expected_signature = sign_message(message, secret_key)\n    return hmac.compare_digest(expected_signature, signature)\n\n# Example usage\nmessage = "Firmware update version 3.0.1"\nsecret_key = "supersecretkey"\nsignature = sign_message(message, secret_key)\n\n# Verification\nis_valid = verify_message(message, signature, secret_key)\nprint(f"Message valid: {is_valid}")\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"5-secure-boot-mechanisms",children:["5. ",(0,i.jsx)(n.strong,{children:"Secure Boot Mechanisms"})]}),"\n",(0,i.jsx)(n.p,{children:"Implement secure boot processes to ensure that only authenticated and authorized firmware is executed on ECUs, preventing the installation of malicious or tampered software."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example: Secure Boot Verification"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:'#include "secure_boot.h"\n#include "crypto.h"\n#include "storage.h"\n#include "logger.h"\n\nbool verify_secure_boot_before_update(const char *public_key_path) {\n    uint8_t bootloader_data[MAX_BOOTLOADER_SIZE];\n    size_t bootloader_size;\n    uint8_t expected_hash[SHA256_DIGEST_LENGTH] = { /* Precomputed hash values */ };\n\n    // Read bootloader data\n    if (!storage_read("bootloader.bin", bootloader_data, &bootloader_size)) {\n        log_error("Failed to read bootloader.");\n        return false;\n    }\n\n    // Compute hash of the bootloader\n    uint8_t computed_hash[SHA256_DIGEST_LENGTH];\n    compute_sha256(bootloader_data, bootloader_size, computed_hash);\n\n    // Compare computed hash with expected hash\n    if (memcmp(computed_hash, expected_hash, SHA256_DIGEST_LENGTH) != 0) {\n        log_error("Bootloader integrity check failed.");\n        return false;\n    }\n\n    log_info("Bootloader verified successfully.");\n    return true;\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-and-reliability",children:"Error Handling and Reliability"}),"\n",(0,i.jsx)(n.p,{children:"Ensuring the reliability of MQTT communications is critical in automotive OTA updates. Implementing robust error handling mechanisms and leveraging MQTT's QoS levels enhances system resilience."}),"\n",(0,i.jsxs)(n.h3,{id:"1-handling-message-loss-and-duplication",children:["1. ",(0,i.jsx)(n.strong,{children:"Handling Message Loss and Duplication"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"QoS 0:"})," Accepts possible message loss without retries."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"QoS 1:"})," Retries sending messages until acknowledgment is received, potentially causing duplicates."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"QoS 2:"})," Ensures exact message delivery without duplication through a handshake process."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example: Implementing Retry Logic for MQTT Publishing"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import paho.mqtt.client as mqtt\nimport json\nimport time\n\ndef publish_with_retry(client, topic, payload, qos=1, retries=3, delay=2):\n    for attempt in range(retries):\n        result = client.publish(topic, json.dumps(payload), qos=qos)\n        status = result.rc\n        if status == mqtt.MQTT_ERR_SUCCESS:\n            print(f"Message published to {topic}")\n            return True\n        else:\n            print(f"Failed to publish message. Attempt {attempt + 1} of {retries}")\n            time.sleep(delay)\n    print("All publish attempts failed.")\n    return False\n\n# Example usage\nclient = mqtt.Client()\nclient.username_pw_set("backend_user", "backend_password")\nclient.connect("mqtt.broker.address", 8883, 60)\npayload = {"version": "3.0.1", "description": "Secure update"}\npublish_with_retry(client, "vehicle/updates/VIN1234567890", payload, qos=1)\nclient.disconnect()\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"2-monitoring-and-alerting",children:["2. ",(0,i.jsx)(n.strong,{children:"Monitoring and Alerting"})]}),"\n",(0,i.jsx)(n.p,{children:"Implement monitoring systems to track the status of OTA updates, detect failures, and alert relevant stakeholders for timely interventions."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example: Failure Notification to Backend"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import requests\nimport json\n\ndef notify_backend_of_failure(vehicle_id, ecu_id, failure_reason):\n    api_endpoint = "https://backend-automanufacturer.com/notify_failure"\n    payload = {\n        "vehicle_id": vehicle_id,\n        "ecu_id": ecu_id,\n        "failure_reason": failure_reason,\n        "timestamp": "2025-04-01T15:30:00Z"\n    }\n    headers = {\'Content-Type\': \'application/json\'}\n\n    response = requests.post(api_endpoint, data=json.dumps(payload), headers=headers)\n    if response.status_code == 200:\n        print(f"Failure notification sent successfully for Vehicle ID: {vehicle_id}, ECU ID: {ecu_id}")\n        return True\n    else:\n        print(f"Failed to send failure notification for Vehicle ID: {vehicle_id}, ECU ID: {ecu_id}")\n        return False\n\n# Example usage\nnotify_backend_of_failure("VIN1234567890", 1, "Hash mismatch during update verification")\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"3-rollback-mechanisms",children:["3. ",(0,i.jsx)(n.strong,{children:"Rollback Mechanisms"})]}),"\n",(0,i.jsx)(n.p,{children:"In the event of a failed update, implement rollback procedures to restore the ECU to its previous stable state, ensuring that the vehicle remains operational."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Example: Initiating Rollback Process"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def rollback_firmware(ecu, backup_firmware_path):\n    import shutil\n\n    try:\n        # Restore backup firmware\n        shutil.copy(backup_firmware_path, "/path/to/current_firmware.bin")\n        reboot_ecu(ecu)\n        display_message(f"Firmware rollback successful for ECU ID: {ecu.id}")\n        notify_backend_of_rollback(ecu.vehicle_id, ecu.id)\n        return True\n    except Exception as e:\n        display_error(f"Firmware rollback failed: {str(e)}")\n        return False\n\ndef reboot_ecu(ecu):\n    # Placeholder function to reboot ECU\n    print(f"Rebooting ECU ID: {ecu.id}")\n\ndef notify_backend_of_rollback(vehicle_id, ecu_id):\n    # Function to notify backend of rollback\n    api_endpoint = "https://backend-automanufacturer.com/rollback_notification"\n    payload = {\n        "vehicle_id": vehicle_id,\n        "ecu_id": ecu_id,\n        "status": "Rolled back to previous firmware version"\n    }\n    headers = {\'Content-Type\': \'application/json\'}\n    response = requests.post(api_endpoint, data=json.dumps(payload), headers=headers)\n    if response.status_code == 200:\n        print(f"Rollback notification sent for Vehicle ID: {vehicle_id}, ECU ID: {ecu_id}")\n    else:\n        print(f"Failed to send rollback notification for Vehicle ID: {vehicle_id}, ECU ID: {ecu_id}")\n\ndef display_message(message):\n    # Function to display message to the user via OEM App\n    print(f"Message: {message}")\n\ndef display_error(message):\n    # Function to display error message to the user via OEM App\n    print(f"Error: {message}")\n\n# Example usage\nclass ECU:\n    def __init__(self, id, vehicle_id):\n        self.id = id\n        self.vehicle_id = vehicle_id\n\necu = ECU(1, "VIN1234567890")\nrollback_firmware(ecu, "path/to/backup_firmware.bin")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-for-mqtt-in-automotive-ota-updates",children:"Best Practices for MQTT in Automotive OTA Updates"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Secure Communication Channels:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Always use TLS/SSL encryption to protect data integrity and confidentiality."}),"\n",(0,i.jsx)(n.li,{children:"Implement certificate-based authentication for enhanced security."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Efficient Topic Structuring:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Design hierarchical and intuitive topic structures to simplify message routing and subscription management."}),"\n",(0,i.jsx)(n.li,{children:"Utilize wildcards judiciously to balance flexibility and specificity."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Optimized QoS Levels:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Select appropriate QoS levels based on the criticality of messages."}),"\n",(0,i.jsxs)(n.li,{children:["Prefer ",(0,i.jsx)(n.strong,{children:"QoS 1"})," for update notifications and ",(0,i.jsx)(n.strong,{children:"QoS 2"})," for firmware installations to ensure reliability."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Robust Error Handling:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implement comprehensive error detection and handling mechanisms to manage message failures, retries, and rollbacks."}),"\n",(0,i.jsx)(n.li,{children:"Monitor MQTT broker performance and health to preemptively address potential issues."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Scalability Considerations:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ensure that the MQTT broker can handle the anticipated load, especially for large fleets."}),"\n",(0,i.jsx)(n.li,{children:"Employ load balancing and clustering strategies to enhance broker scalability and resilience."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Regular Security Audits:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Conduct periodic security assessments to identify and mitigate vulnerabilities."}),"\n",(0,i.jsx)(n.li,{children:"Update encryption protocols and authentication mechanisms in line with evolving security standards."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"MQTT Connectivity"})," is the backbone of efficient and secure OTA update systems in the automotive industry. Its lightweight nature, coupled with robust publish/subscribe capabilities, ensures that vehicles can receive timely software updates without overburdening network resources. By adhering to best practices in security, topic structuring, and error handling, automotive OEMs can leverage MQTT to enhance vehicle performance, safety, and user satisfaction. As the automotive landscape continues to evolve towards more connected and autonomous systems, MQTT's role in facilitating seamless communication and reliable updates will become increasingly indispensable."]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var t=s(96540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);