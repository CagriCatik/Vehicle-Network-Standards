"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[56849],{13423:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"AUTOSAR/application/architecture","title":"Overview of Software Layers","description":"The AUTOSAR (AUTomotive Open System ARchitecture) Classic Platform is a standardized software architecture designed to support the development of embedded systems in vehicles. This architecture ensures compatibility, scalability, and modularity while promoting reusability and reducing development complexity. Below is an overview of the key layers in the AUTOSAR Classic Platform, as illustrated in the image.","source":"@site/docs/AUTOSAR/02_application/01_architecture.md","sourceDirName":"AUTOSAR/02_application","slug":"/AUTOSAR/application/architecture","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/application/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AUTOSAR/02_application/01_architecture.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"autosarSidebar","previous":{"title":"Application","permalink":"/Vehicle-Network-Standards/docs/category/application"},"next":{"title":"Components View for Lighting Control","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/application/components"}}');var s=i(74848),t=i(28453);const a={},l="Overview of Software Layers",o={},c=[{value:"1. <strong>Application Layer</strong>",id:"1-application-layer",level:2},{value:"Key Features:",id:"key-features",level:3},{value:"Example:",id:"example",level:3},{value:"2. <strong>Runtime Environment (RTE)</strong>",id:"2-runtime-environment-rte",level:2},{value:"Key Features:",id:"key-features-1",level:3},{value:"Example:",id:"example-1",level:3},{value:"3. <strong>Services Layer</strong>",id:"3-services-layer",level:2},{value:"Subcomponents:",id:"subcomponents",level:3},{value:"Example Code Snippet:",id:"example-code-snippet",level:3},{value:"4. <strong>ECU Abstraction Layer</strong>",id:"4-ecu-abstraction-layer",level:2},{value:"Key Features:",id:"key-features-2",level:3},{value:"Example:",id:"example-2",level:3},{value:"5. <strong>Microcontroller Abstraction Layer (MCAL)</strong>",id:"5-microcontroller-abstraction-layer-mcal",level:2},{value:"Key Features:",id:"key-features-3",level:3},{value:"Example Code Snippet:",id:"example-code-snippet-1",level:3},{value:"6. <strong>Complex Drivers</strong>",id:"6-complex-drivers",level:2},{value:"Key Features:",id:"key-features-4",level:3},{value:"Example:",id:"example-3",level:3},{value:"7. <strong>Microcontroller</strong>",id:"7-microcontroller",level:2},{value:"Key Features:",id:"key-features-5",level:3},{value:"Example:",id:"example-4",level:3},{value:"Benefits of the AUTOSAR Layered Architecture",id:"benefits-of-the-autosar-layered-architecture",level:2},{value:"Advanced Notes for Practitioners",id:"advanced-notes-for-practitioners",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"overview-of-software-layers",children:"Overview of Software Layers"})}),"\n",(0,s.jsx)(n.p,{children:"The AUTOSAR (AUTomotive Open System ARchitecture) Classic Platform is a standardized software architecture designed to support the development of embedded systems in vehicles. This architecture ensures compatibility, scalability, and modularity while promoting reusability and reducing development complexity. Below is an overview of the key layers in the AUTOSAR Classic Platform, as illustrated in the image."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"1-application-layer",children:["1. ",(0,s.jsx)(n.strong,{children:"Application Layer"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Application Layer"})," contains the application-specific software components that implement the functional behavior of the system. These components communicate with the underlying layers through standardized interfaces provided by the ",(0,s.jsx)(n.strong,{children:"Runtime Environment (RTE)"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"key-features",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implements vehicle-specific functionalities such as powertrain, infotainment, and body control systems."}),"\n",(0,s.jsx)(n.li,{children:"High-level logic with minimal hardware dependencies."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"An application software component might include code for cruise control, implementing features like maintaining vehicle speed."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"2-runtime-environment-rte",children:["2. ",(0,s.jsx)(n.strong,{children:"Runtime Environment (RTE)"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Runtime Environment"})," acts as a middleware, enabling communication between the ",(0,s.jsx)(n.strong,{children:"Application Layer"})," and the ",(0,s.jsx)(n.strong,{children:"Basic Software (BSW)"})," layers. It abstracts the hardware dependencies and ensures standardized interaction."]}),"\n",(0,s.jsx)(n.h3,{id:"key-features-1",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Manages inter-component communication."}),"\n",(0,s.jsx)(n.li,{children:"Facilitates service access (e.g., diagnostic services, network management)."}),"\n",(0,s.jsx)(n.li,{children:"Provides a hardware-independent interface to the Application Layer."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-1",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"The RTE may handle the transmission of data between an application component controlling the headlights and another managing the vehicle's CAN bus."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"3-services-layer",children:["3. ",(0,s.jsx)(n.strong,{children:"Services Layer"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Services Layer"})," offers a set of generic and application-independent services used by the Application Layer and other Basic Software layers. These services include system functionalities and utility functions."]}),"\n",(0,s.jsx)(n.h3,{id:"subcomponents",children:"Subcomponents:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Operating System (OS):"})," Provides task scheduling, interrupt handling, and resource management."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Communication Services:"})," Handles network communication, including CAN, LIN, and FlexRay protocols."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Diagnostic Services:"})," Supports UDS (Unified Diagnostic Services) for ECU diagnostics."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Services:"})," Manages EEPROM, Flash, and RAM memory."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-code-snippet",children:"Example Code Snippet:"}),"\n",(0,s.jsx)(n.p,{children:"A diagnostic service implementation for reading ECU status might look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"void Diagnostic_ReadStatus(void) {\n    // Example implementation of UDS Diagnostic Service\n    ReadECUStatus();\n    SendResponseToTester();\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"4-ecu-abstraction-layer",children:["4. ",(0,s.jsx)(n.strong,{children:"ECU Abstraction Layer"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"ECU Abstraction Layer"})," abstracts the hardware details of the ECU (Electronic Control Unit) and provides a uniform API to the higher layers. It ensures hardware independence by encapsulating the specific properties of microcontrollers and other hardware components."]}),"\n",(0,s.jsx)(n.h3,{id:"key-features-2",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Interfaces with hardware peripherals such as ADC, PWM, and GPIO."}),"\n",(0,s.jsx)(n.li,{children:"Manages input/output drivers and communication peripherals."}),"\n",(0,s.jsx)(n.li,{children:"Provides APIs for hardware access without exposing hardware-specific details."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-2",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"The abstraction of ADC reads for a temperature sensor would be handled here."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"5-microcontroller-abstraction-layer-mcal",children:["5. ",(0,s.jsx)(n.strong,{children:"Microcontroller Abstraction Layer (MCAL)"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"MCAL"})," is the lowest layer of the Basic Software and directly interacts with the microcontroller hardware. It provides standardized interfaces for accessing microcontroller peripherals and ensures deterministic behavior."]}),"\n",(0,s.jsx)(n.h3,{id:"key-features-3",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Manages peripherals like timers, I/O ports, and ADC."}),"\n",(0,s.jsx)(n.li,{children:"Ensures real-time behavior and compliance with hardware standards."}),"\n",(0,s.jsx)(n.li,{children:"Serves as the foundation for the ECU Abstraction Layer."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-code-snippet-1",children:"Example Code Snippet:"}),"\n",(0,s.jsx)(n.p,{children:"Configuring a timer using MCAL:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"void Timer_Init(void) {\n    Timer_Configuration();\n    Timer_Start();\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"6-complex-drivers",children:["6. ",(0,s.jsx)(n.strong,{children:"Complex Drivers"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complex Drivers"})," are special software modules designed to handle hardware that does not fit neatly into the standard AUTOSAR architecture. These drivers can bypass the layered architecture to achieve optimized performance for specific hardware."]}),"\n",(0,s.jsx)(n.h3,{id:"key-features-4",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Directly interacts with hardware for specific use cases."}),"\n",(0,s.jsx)(n.li,{children:"Often used for time-critical or proprietary functionalities."}),"\n",(0,s.jsx)(n.li,{children:"Can interface directly with the Application Layer."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-3",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"A custom driver for a proprietary sensor may fall under this category."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"7-microcontroller",children:["7. ",(0,s.jsx)(n.strong,{children:"Microcontroller"})]}),"\n",(0,s.jsxs)(n.p,{children:["At the foundation of the architecture lies the ",(0,s.jsx)(n.strong,{children:"Microcontroller"}),", the physical hardware executing all the software layers. It includes the CPU, memory, and integrated peripherals, providing the computational resources for the embedded system."]}),"\n",(0,s.jsx)(n.h3,{id:"key-features-5",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Executes all AUTOSAR software components."}),"\n",(0,s.jsx)(n.li,{children:"Interfaces with sensors, actuators, and communication networks."}),"\n",(0,s.jsx)(n.li,{children:"Supported by the MCAL for seamless integration."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"example-4",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"Microcontrollers such as Infineon AURIX or NXP S32K are commonly used in AUTOSAR-based systems."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"benefits-of-the-autosar-layered-architecture",children:"Benefits of the AUTOSAR Layered Architecture"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability:"})," Modular design allows easy scaling of software for different ECUs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reusability:"})," Standardized interfaces enable software reuse across projects."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware Independence:"})," Abstraction layers decouple hardware and software development."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Standardization:"})," Ensures compatibility between components from different suppliers."]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"advanced-notes-for-practitioners",children:"Advanced Notes for Practitioners"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RTE Configuration:"})," Customizing the RTE for specific application components is critical to ensure optimal performance."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MCAL Customization:"})," While MCAL is hardware-dependent, careful configuration ensures seamless interaction with higher layers."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration Testing:"})," Testing the interaction between layers, especially Application and Basic Software, is essential for system reliability."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var r=i(96540);const s={},t=r.createContext(s);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);