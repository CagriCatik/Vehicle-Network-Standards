"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[56849],{13423:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"AUTOSAR/application/architecture","title":"Overview of Software Layers","description":"The AUTOSAR (AUTomotive Open System ARchitecture) Classic Platform is a standardized software architecture tailored to support the development of embedded systems within vehicles. By emphasizing compatibility, scalability, and modularity, AUTOSAR facilitates reusability and diminishes development complexity. This documentation provides a comprehensive overview of the key layers in the AUTOSAR Classic Platform, detailing their functionalities, features, and interrelationships.","source":"@site/docs/AUTOSAR/02_application/01_architecture.md","sourceDirName":"AUTOSAR/02_application","slug":"/AUTOSAR/application/architecture","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/application/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AUTOSAR/02_application/01_architecture.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"autosarSidebar","previous":{"title":"Application","permalink":"/Vehicle-Network-Standards/docs/category/application"},"next":{"title":"Components View for Lighting Control","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/application/components"}}');var t=i(74848),s=i(28453);const a={},o="Overview of Software Layers",l={},c=[{value:"1. <strong>Application Layer</strong>",id:"1-application-layer",level:2},{value:"Key Features:",id:"key-features",level:3},{value:"Example:",id:"example",level:3},{value:"2. <strong>Runtime Environment (RTE)</strong>",id:"2-runtime-environment-rte",level:2},{value:"Key Features:",id:"key-features-1",level:3},{value:"Example:",id:"example-1",level:3},{value:"3. <strong>Services Layer</strong>",id:"3-services-layer",level:2},{value:"Subcomponents:",id:"subcomponents",level:3},{value:"Example Code Snippet:",id:"example-code-snippet",level:3},{value:"4. <strong>ECU Abstraction Layer</strong>",id:"4-ecu-abstraction-layer",level:2},{value:"Key Features:",id:"key-features-2",level:3},{value:"Example:",id:"example-2",level:3},{value:"5. <strong>Microcontroller Abstraction Layer (MCAL)</strong>",id:"5-microcontroller-abstraction-layer-mcal",level:2},{value:"Key Features:",id:"key-features-3",level:3},{value:"Example Code Snippet:",id:"example-code-snippet-1",level:3},{value:"6. <strong>Complex Drivers</strong>",id:"6-complex-drivers",level:2},{value:"Key Features:",id:"key-features-4",level:3},{value:"Example:",id:"example-3",level:3},{value:"7. <strong>Microcontroller</strong>",id:"7-microcontroller",level:2},{value:"Key Features:",id:"key-features-5",level:3},{value:"Example:",id:"example-4",level:3},{value:"Benefits of the AUTOSAR Layered Architecture",id:"benefits-of-the-autosar-layered-architecture",level:2},{value:"Advanced Notes for Practitioners",id:"advanced-notes-for-practitioners",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"overview-of-software-layers",children:"Overview of Software Layers"})}),"\n",(0,t.jsx)(n.p,{children:"The AUTOSAR (AUTomotive Open System ARchitecture) Classic Platform is a standardized software architecture tailored to support the development of embedded systems within vehicles. By emphasizing compatibility, scalability, and modularity, AUTOSAR facilitates reusability and diminishes development complexity. This documentation provides a comprehensive overview of the key layers in the AUTOSAR Classic Platform, detailing their functionalities, features, and interrelationships."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"1-application-layer",children:["1. ",(0,t.jsx)(n.strong,{children:"Application Layer"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"Application Layer"})," encompasses the application-specific software components responsible for implementing the functional behavior of the vehicle's embedded systems. These components interact with the lower layers through standardized interfaces provided by the ",(0,t.jsx)(n.strong,{children:"Runtime Environment (RTE)"}),", ensuring seamless communication and integration."]}),"\n",(0,t.jsx)(n.h3,{id:"key-features",children:"Key Features:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Vehicle-Specific Functionalities:"})," Implements features such as powertrain control, infotainment systems, body control modules, and more."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"High-Level Logic:"})," Focuses on the application logic with minimal dependencies on hardware specifics, promoting portability and flexibility."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"Consider a cruise control system within a vehicle. The application software component for cruise control would include functionalities like maintaining the vehicle's speed, adjusting throttle positions, and responding to driver inputs. Below is a simplified representation of such a component:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// CruiseControl.c\n#include "CruiseControl.h"\n#include "RTE_CruiseControl.h"\n\nvoid CruiseControl_UpdateSpeed(void) {\n    uint16 currentSpeed = RTE_GetCurrentSpeed();\n    uint16 targetSpeed = RTE_GetTargetSpeed();\n\n    if (currentSpeed < targetSpeed) {\n        Accelerate();\n    } else if (currentSpeed > targetSpeed) {\n        Decelerate();\n    }\n}\n\nvoid Accelerate(void) {\n    // Logic to increase vehicle speed\n    RTE_SetThrottlePosition(RTE_GetThrottlePosition() + 5);\n}\n\nvoid Decelerate(void) {\n    // Logic to decrease vehicle speed\n    RTE_SetThrottlePosition(RTE_GetThrottlePosition() - 5);\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"2-runtime-environment-rte",children:["2. ",(0,t.jsx)(n.strong,{children:"Runtime Environment (RTE)"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"Runtime Environment (RTE)"})," serves as a middleware layer that facilitates communication between the ",(0,t.jsx)(n.strong,{children:"Application Layer"})," and the ",(0,t.jsx)(n.strong,{children:"Basic Software (BSW)"})," layers. By abstracting hardware dependencies, the RTE ensures standardized interactions and seamless data exchange across different software components."]}),"\n",(0,t.jsx)(n.h3,{id:"key-features-1",children:"Key Features:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inter-Component Communication:"})," Manages data exchange between various application components."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Access:"})," Provides access to essential services such as diagnostics, network management, and more."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware Independence:"})," Offers a consistent interface to the Application Layer, regardless of underlying hardware variations."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-1",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"In a scenario where an application component manages the vehicle's headlights and another manages the CAN bus communication, the RTE ensures that data is correctly transmitted between these components without exposing hardware-specific details."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// HeadlightController.c\n#include "HeadlightController.h"\n#include "RTE_HeadlightController.h"\n\nvoid HeadlightController_SetState(bool state) {\n    RTE_SendHeadlightState(state);\n}\n\nbool HeadlightController_GetState(void) {\n    return RTE_ReceiveHeadlightState();\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"3-services-layer",children:["3. ",(0,t.jsx)(n.strong,{children:"Services Layer"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"Services Layer"})," provides a collection of generic, application-independent services utilized by both the Application Layer and other Basic Software layers. These services encompass a wide range of system functionalities and utility functions essential for the smooth operation of the embedded system."]}),"\n",(0,t.jsx)(n.h3,{id:"subcomponents",children:"Subcomponents:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Operating System (OS):"})," Handles task scheduling, interrupt management, and resource allocation to ensure efficient system operation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Communication Services:"})," Manages network communications, supporting protocols such as CAN, LIN, and FlexRay."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Diagnostic Services:"})," Facilitates ECU diagnostics through protocols like UDS (Unified Diagnostic Services)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Services:"})," Oversees memory management, including EEPROM, Flash, and RAM operations."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-code-snippet",children:"Example Code Snippet:"}),"\n",(0,t.jsx)(n.p,{children:"Implementing a diagnostic service to read the status of an ECU might involve the following code:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// DiagnosticService.c\n#include "DiagnosticService.h"\n#include "ECUStatus.h"\n#include "RTE_DiagnosticService.h"\n\nvoid Diagnostic_ReadStatus(void) {\n    ECUStatus_t status = ReadECUStatus();\n    RTE_SendDiagnosticResponse(status);\n}\n\nECUStatus_t ReadECUStatus(void) {\n    // Implementation to read ECU status\n    ECUStatus_t status;\n    // Populate status based on ECU readings\n    return status;\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"4-ecu-abstraction-layer",children:["4. ",(0,t.jsx)(n.strong,{children:"ECU Abstraction Layer"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"ECU Abstraction Layer"})," is responsible for abstracting the hardware specifics of the Electronic Control Unit (ECU). By providing a uniform API to the higher layers, it ensures that software components remain independent of the underlying hardware, facilitating portability and scalability."]}),"\n",(0,t.jsx)(n.h3,{id:"key-features-2",children:"Key Features:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware Peripheral Interfaces:"})," Manages interactions with hardware peripherals such as ADCs (Analog-to-Digital Converters), PWMs (Pulse Width Modulators), and GPIOs (General-Purpose Input/Output)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"I/O Drivers Management:"})," Handles input and output drivers, ensuring efficient communication with various hardware components."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Uniform API Provision:"})," Offers a consistent interface for hardware access, hiding the complexities and specifics of the actual hardware."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-2",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"Handling ADC reads for a temperature sensor involves abstracting the hardware details to provide a simple API for higher layers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// TempSensor.c\n#include "TempSensor.h"\n#include "ECU_Abstraction.h"\n\nfloat TempSensor_ReadTemperature(void) {\n    uint16 adcValue = ECU_ReadADC(TEMP_SENSOR_CHANNEL);\n    return ConvertADCToTemperature(adcValue);\n}\n\nfloat ConvertADCToTemperature(uint16 adcValue) {\n    // Conversion logic from ADC value to temperature\n    return (float)adcValue * 0.1f; // Example conversion factor\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"5-microcontroller-abstraction-layer-mcal",children:["5. ",(0,t.jsx)(n.strong,{children:"Microcontroller Abstraction Layer (MCAL)"})]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"Microcontroller Abstraction Layer (MCAL)"})," constitutes the lowest layer of the Basic Software, interfacing directly with the microcontroller hardware. It provides standardized interfaces for accessing microcontroller peripherals, ensuring deterministic behavior and compliance with hardware standards."]}),"\n",(0,t.jsx)(n.h3,{id:"key-features-3",children:"Key Features:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Peripheral Management:"})," Controls peripherals such as timers, I/O ports, and ADCs, providing a standardized interface for higher layers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Real-Time Compliance:"})," Ensures real-time performance and behavior, crucial for time-sensitive automotive applications."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Foundation for ECU Abstraction:"})," Serves as the underlying layer upon which the ECU Abstraction Layer is built, facilitating seamless integration."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-code-snippet-1",children:"Example Code Snippet:"}),"\n",(0,t.jsx)(n.p,{children:"Configuring a timer using the MCAL might involve the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// Timer.c\n#include "Timer.h"\n#include "MCAL_Timer.h"\n\nvoid Timer_Init(void) {\n    MCAL_Timer_Configure(TIMER0, PRESCALER_64, MODE_PERIODIC);\n    MCAL_Timer_Start(TIMER0);\n}\n\nvoid Timer_Start(void) {\n    MCAL_Timer_EnableInterrupt(TIMER0, Timer_InterruptHandler);\n    MCAL_Timer_Start(TIMER0);\n}\n\nvoid Timer_InterruptHandler(void) {\n    // Handler code executed on timer interrupt\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"6-complex-drivers",children:["6. ",(0,t.jsx)(n.strong,{children:"Complex Drivers"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Complex Drivers"})," are specialized software modules designed to manage hardware components that do not conform neatly to the standard AUTOSAR layered architecture. These drivers often bypass certain layers to achieve optimized performance tailored to specific hardware requirements."]}),"\n",(0,t.jsx)(n.h3,{id:"key-features-4",children:"Key Features:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Direct Hardware Interaction:"})," Facilitates direct communication with hardware for specialized use cases, enhancing performance and efficiency."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Time-Critical Operations:"})," Suitable for functionalities that demand precise timing and low latency."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Proprietary Functionalities:"})," Enables support for proprietary or non-standard hardware components that require unique handling."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-3",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"Developing a custom driver for a proprietary sensor that requires specialized communication protocols or timing constraints can be implemented as a Complex Driver:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// CustomSensorDriver.c\n#include "CustomSensorDriver.h"\n\nvoid CustomSensor_Init(void) {\n    // Initialize proprietary sensor communication\n    ProprietaryComm_Init();\n}\n\nuint16 CustomSensor_ReadData(void) {\n    // Directly interact with proprietary hardware to read sensor data\n    uint16 data = ProprietaryComm_Read();\n    return data;\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"7-microcontroller",children:["7. ",(0,t.jsx)(n.strong,{children:"Microcontroller"})]}),"\n",(0,t.jsxs)(n.p,{children:["At the base of the AUTOSAR architecture lies the ",(0,t.jsx)(n.strong,{children:"Microcontroller"}),", the physical hardware platform that executes all software layers. It comprises the CPU, memory, and integrated peripherals, providing the computational resources necessary for the embedded system's operation."]}),"\n",(0,t.jsx)(n.h3,{id:"key-features-5",children:"Key Features:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution of Software Components:"})," Runs all AUTOSAR software layers, from the Application Layer down to the MCAL."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Peripheral Integration:"})," Interfaces seamlessly with various sensors, actuators, and communication networks, enabling comprehensive system functionality."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Supported by MCAL:"})," The MCAL ensures that the microcontroller's capabilities are accessible and manageable by higher software layers."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-4",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"Popular microcontrollers used in AUTOSAR-based systems include the Infineon AURIX and NXP S32K families. These microcontrollers offer robust performance, extensive peripheral support, and compatibility with AUTOSAR standards."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"benefits-of-the-autosar-layered-architecture",children:"Benefits of the AUTOSAR Layered Architecture"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability:"})," The modular design of AUTOSAR allows for effortless scaling of software across different ECUs, accommodating a wide range of vehicle applications."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reusability:"})," Standardized interfaces and component-based architecture enable the reuse of software modules across various projects, reducing development time and costs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware Independence:"})," Through abstraction layers, AUTOSAR decouples hardware and software development, allowing for greater flexibility and adaptability to different hardware platforms."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Standardization:"})," Ensures compatibility and interoperability between components sourced from different suppliers, fostering a collaborative and efficient development ecosystem."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"advanced-notes-for-practitioners",children:"Advanced Notes for Practitioners"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"RTE Configuration:"})," Tailoring the RTE to accommodate specific application components is pivotal for achieving optimal system performance. Proper configuration ensures efficient data routing and resource utilization."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"MCAL Customization:"})," Although the MCAL is inherently hardware-dependent, meticulous configuration and customization are essential to guarantee seamless interaction with higher software layers. This includes setting up appropriate peripheral parameters and interrupt handling mechanisms."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Integration Testing:"})," Rigorous testing of interactions between different layers, especially between the Application and Basic Software layers, is crucial for ensuring system reliability and robustness. This involves validating communication protocols, service integrations, and performance under various operating conditions."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var r=i(96540);const t={},s=r.createContext(t);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);