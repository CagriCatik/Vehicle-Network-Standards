"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[9661],{46054:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>u,default:()=>c,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"CAN/CAN-Datensicherung/nrz-codierung","title":"Bitcodierung im CAN-Bus","description":"In diesem Teil werden wir die Grundlagen der Bitcodierung im CAN-Bus (Controller Area Network) untersuchen, insbesondere die NRZ-Bitcodierung und deren Bedeutung f\xfcr die St\xf6rfestigkeit und die Synchronisation.","source":"@site/docs/CAN/05_CAN-Datensicherung/02_nrz-codierung.md","sourceDirName":"CAN/05_CAN-Datensicherung","slug":"/CAN/CAN-Datensicherung/nrz-codierung","permalink":"/Vehicle-Network-Standards/docs/CAN/CAN-Datensicherung/nrz-codierung","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/CAN/05_CAN-Datensicherung/02_nrz-codierung.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"canSidebar","previous":{"title":"Datenintegrit\xe4t im Kfz","permalink":"/Vehicle-Network-Standards/docs/CAN/CAN-Datensicherung/datensicherung"},"next":{"title":"Symmetrische Signal\xfcbertragung","permalink":"/Vehicle-Network-Standards/docs/CAN/CAN-Datensicherung/twisted-pair"}}');var t=i(74848),s=i(28453);const d={},u="Bitcodierung im CAN-Bus",o={},l=[{value:"Einleitung",id:"einleitung",level:2},{value:"NRZ-Bitcodierung",id:"nrz-bitcodierung",level:2},{value:"Grundlagen der NRZ-Codierung",id:"grundlagen-der-nrz-codierung",level:3},{value:"Vorteile der NRZ-Codierung",id:"vorteile-der-nrz-codierung",level:4},{value:"Herausforderungen der NRZ-Codierung",id:"herausforderungen-der-nrz-codierung",level:3},{value:"Fehlende Synchronisation",id:"fehlende-synchronisation",level:4},{value:"Synchronisationsmechanismen",id:"synchronisationsmechanismen",level:2},{value:"Bitstuffing zur Synchronisation",id:"bitstuffing-zur-synchronisation",level:3},{value:"Beispiel f\xfcr Bitstuffing",id:"beispiel-f\xfcr-bitstuffing",level:4},{value:"Vergleich mit Manchester-Codierung",id:"vergleich-mit-manchester-codierung",level:3},{value:"Fazit",id:"fazit",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"bitcodierung-im-can-bus",children:"Bitcodierung im CAN-Bus"})}),"\n",(0,t.jsx)(n.p,{children:"In diesem Teil werden wir die Grundlagen der Bitcodierung im CAN-Bus (Controller Area Network) untersuchen, insbesondere die NRZ-Bitcodierung und deren Bedeutung f\xfcr die St\xf6rfestigkeit und die Synchronisation."}),"\n",(0,t.jsx)(n.h2,{id:"einleitung",children:"Einleitung"}),"\n",(0,t.jsx)(n.p,{children:"Die Bitcodierung spielt eine zentrale Rolle bei der Kommunikation in Fahrzeugnetzwerken, da sie sowohl die \xdcbertragungseffizienz als auch die St\xf6rfestigkeit beeinflusst. Im Kontext des CAN-Bus, der in der Automobilindustrie weit verbreitet ist, wurde die NRZ-Bitcodierung (Non Return to Zero) gew\xe4hlt. Wir werden die Gr\xfcnde f\xfcr diese Wahl und die damit verbundenen Herausforderungen im Detail beleuchten."}),"\n",(0,t.jsx)(n.h2,{id:"nrz-bitcodierung",children:"NRZ-Bitcodierung"}),"\n",(0,t.jsx)(n.h3,{id:"grundlagen-der-nrz-codierung",children:"Grundlagen der NRZ-Codierung"}),"\n",(0,t.jsx)(n.p,{children:"Die NRZ-Bitcodierung ist eine Methode zur Abbildung von Bin\xe4rsignalen, bei der eine logische \u201e1\u201c durch einen hohen Pegel und eine logische \u201e0\u201c durch einen niedrigen Pegel dargestellt wird. Ein wesentliches Merkmal dieser Codierung ist, dass bei aufeinanderfolgenden Bits gleicher Polarit\xe4t keine Pegel\xe4nderung stattfindet."}),"\n",(0,t.jsx)(n.h4,{id:"vorteile-der-nrz-codierung",children:"Vorteile der NRZ-Codierung"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hohe Datenraten"}),": Die NRZ-Codierung erm\xf6glicht hohe Datenraten, da keine zus\xe4tzlichen \xdcberg\xe4nge zwischen den Bits erforderlich sind."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reduzierte Emissionen"}),": Durch die Minimierung der Pegel\xe4nderungen wird die elektromagnetische Abstrahlung reduziert, was die Emissionen verringert und somit die St\xf6rfestigkeit verbessert."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"herausforderungen-der-nrz-codierung",children:"Herausforderungen der NRZ-Codierung"}),"\n",(0,t.jsx)(n.h4,{id:"fehlende-synchronisation",children:"Fehlende Synchronisation"}),"\n",(0,t.jsx)(n.p,{children:"Ein Hauptnachteil der NRZ-Codierung ist das Fehlen von Synchronisationseigenschaften. Bei langen Sequenzen gleicher Bits (homogene Bits) findet keine Pegel\xe4nderung statt, wodurch der Empf\xe4nger die Synchronisation verlieren kann. Dies bedeutet, dass der Empf\xe4nger Schwierigkeiten hat, den Anfang und das Ende eines Bits korrekt zu erkennen, was zu Kommunikationsfehlern f\xfchren kann."}),"\n",(0,t.jsx)(n.h2,{id:"synchronisationsmechanismen",children:"Synchronisationsmechanismen"}),"\n",(0,t.jsx)(n.p,{children:"Um die Synchronisation bei der Verwendung der NRZ-Codierung zu gew\xe4hrleisten, sind zus\xe4tzliche Mechanismen erforderlich. Der CAN-Bus nutzt das sogenannte Bitstuffing-Verfahren zur Synchronisation."}),"\n",(0,t.jsx)(n.h3,{id:"bitstuffing-zur-synchronisation",children:"Bitstuffing zur Synchronisation"}),"\n",(0,t.jsx)(n.p,{children:"Beim Bitstuffing wird nach f\xfcnf aufeinanderfolgenden Bits gleicher Polarit\xe4t ein komplement\xe4res Bit eingef\xfcgt. Dieses zus\xe4tzliche Bit erzeugt eine Pegel\xe4nderung, die dem Empf\xe4nger als Synchronisationssignal dient. Auf diese Weise wird verhindert, dass lange Sequenzen ohne Pegel\xe4nderung auftreten, was die Synchronisation sicherstellt."}),"\n",(0,t.jsx)(n.h4,{id:"beispiel-f\xfcr-bitstuffing",children:"Beispiel f\xfcr Bitstuffing"}),"\n",(0,t.jsx)(n.p,{children:"Betrachten wir eine Bitfolge, die nur aus logischen \u201e1\u201c-Bits besteht:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Original-Bitfolge: ",(0,t.jsx)(n.code,{children:"11111"})]}),"\n",(0,t.jsxs)(n.li,{children:["Nach Bitstuffing: ",(0,t.jsx)(n.code,{children:"111110"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Hier wurde nach f\xfcnf aufeinanderfolgenden \u201e1\u201c-Bits eine \u201e0\u201c eingef\xfcgt. Dieser Mechanismus stellt sicher, dass der Empf\xe4nger die Synchronisation beibeh\xe4lt, auch wenn die urspr\xfcngliche Bitfolge keine Pegel\xe4nderung aufweist."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"CAN-Netzwerk",src:i(70143).A+"",width:"966",height:"465"})}),"\n",(0,t.jsx)(n.h3,{id:"vergleich-mit-manchester-codierung",children:"Vergleich mit Manchester-Codierung"}),"\n",(0,t.jsx)(n.p,{children:"Im Gegensatz zur NRZ-Codierung ist die Manchester-Codierung selbsttaktend. Bei der Manchester-Codierung wird jedes Bit durch eine Pegel\xe4nderung dargestellt, was eine inh\xe4rente Synchronisation gew\xe4hrleistet. Allerdings verdoppelt sich dadurch die Bandbreite, da f\xfcr jedes Datenbit zwei Pegel\xe4nderungen erforderlich sind. Dies f\xfchrt zu h\xf6heren Emissionen und geringerer \xdcbertragungseffizienz im Vergleich zur NRZ-Codierung."}),"\n",(0,t.jsx)(n.h2,{id:"fazit",children:"Fazit"}),"\n",(0,t.jsx)(n.p,{children:"Die Wahl der NRZ-Bitcodierung f\xfcr den CAN-Bus bietet klare Vorteile in Bezug auf hohe Datenraten und reduzierte Emissionen. Allerdings erfordert sie zus\xe4tzliche Synchronisationsmechanismen wie das Bitstuffing, um die zuverl\xe4ssige Daten\xfcbertragung zu gew\xe4hrleisten. Durch das Verst\xe4ndnis dieser Techniken k\xf6nnen Ingenieure und Entwickler die Leistungsf\xe4higkeit und St\xf6rfestigkeit von Fahrzeugnetzwerken optimieren."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},70143:(e,n,i)=>{i.d(n,{A:()=>r});const r=i.p+"assets/images/1712276628306-52e7c2960b7b9f563db40a2f66306c5d.png"},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>u});var r=i(96540);const t={},s=r.createContext(t);function d(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);