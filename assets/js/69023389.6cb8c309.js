"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[39026],{53594:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"OTA/target-device/uds-can","title":"UDS over CAN","description":"Unified Diagnostic Services (UDS) is a communication protocol used in automotive systems for diagnostics and vehicle control. When implemented over the Controller Area Network (CAN), UDS enables efficient and standardized communication between electronic control units (ECUs) within a vehicle. This documentation delves into the intricacies of UDS over CAN, elucidating the structure of CAN traces, message framing, transfer protocols, flow control mechanisms, and timing considerations essential for advanced diagnostics and data transfer operations.","source":"@site/docs/OTA/07_target-device/03_uds-can.md","sourceDirName":"OTA/07_target-device","slug":"/OTA/target-device/uds-can","permalink":"/Vehicle-Network-Standards/docs/OTA/target-device/uds-can","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/OTA/07_target-device/03_uds-can.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"otaSidebar","previous":{"title":"Diagnostics over Ethernet and CAN in AUTOSAR","permalink":"/Vehicle-Network-Standards/docs/OTA/target-device/autosar"},"next":{"title":"UDS over Ethernet","permalink":"/Vehicle-Network-Standards/docs/OTA/target-device/doip"}}');var r=s(74848),t=s(28453);const a={},l="UDS over CAN",o={},d=[{value:"CAN Trace Structure",id:"can-trace-structure",level:2},{value:"Example CAN Trace",id:"example-can-trace",level:3},{value:"Data Length Code (DLC) and Message Addressing",id:"data-length-code-dlc-and-message-addressing",level:2},{value:"Message Addressing",id:"message-addressing",level:3},{value:"Transfer Protocol",id:"transfer-protocol",level:2},{value:"Frame Types",id:"frame-types",level:3},{value:"Example of Frame Sequence",id:"example-of-frame-sequence",level:3},{value:"First Frame (FF)",id:"first-frame-ff",level:4},{value:"Flow Control Frame (FC)",id:"flow-control-frame-fc",level:4},{value:"Consecutive Frames (CF)",id:"consecutive-frames-cf",level:4},{value:"Flow Control Mechanism",id:"flow-control-mechanism",level:2},{value:"Flow Status",id:"flow-status",level:3},{value:"Block Size and Separation Time",id:"block-size-and-separation-time",level:3},{value:"Consecutive Frames and Data Consumption",id:"consecutive-frames-and-data-consumption",level:2},{value:"Block Size and Transfer Flow",id:"block-size-and-transfer-flow",level:2},{value:"Transfer Sequence",id:"transfer-sequence",level:3},{value:"Example Flow",id:"example-flow",level:3},{value:"Timing Considerations",id:"timing-considerations",level:2},{value:"Period DT (Response Time)",id:"period-dt-response-time",level:3},{value:"Response Time and Message Gap",id:"response-time-and-message-gap",level:3},{value:"Practical Example of Data Transfer",id:"practical-example-of-data-transfer",level:2},{value:"Code Snippets",id:"code-snippets",level:2},{value:"Sending a First Frame",id:"sending-a-first-frame",level:3},{value:"Handling Flow Control Frame",id:"handling-flow-control-frame",level:3},{value:"Sending Consecutive Frames",id:"sending-consecutive-frames",level:3},{value:"Example Usage",id:"example-usage",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"uds-over-can",children:"UDS over CAN"})}),"\n",(0,r.jsx)(n.p,{children:"Unified Diagnostic Services (UDS) is a communication protocol used in automotive systems for diagnostics and vehicle control. When implemented over the Controller Area Network (CAN), UDS enables efficient and standardized communication between electronic control units (ECUs) within a vehicle. This documentation delves into the intricacies of UDS over CAN, elucidating the structure of CAN traces, message framing, transfer protocols, flow control mechanisms, and timing considerations essential for advanced diagnostics and data transfer operations."}),"\n",(0,r.jsx)(n.h2,{id:"can-trace-structure",children:"CAN Trace Structure"}),"\n",(0,r.jsx)(n.p,{children:"Understanding CAN trace structure is fundamental to comprehending UDS communications. A CAN trace typically comprises several components:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Timestamp"}),": Indicates the exact time a message is transmitted or received."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Type"}),": Specifies whether the message is transmitted (Tx) or received (Rx)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Length Code (DLC)"}),": Denotes the length of the data payload in bytes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Address"}),": The identifier for the CAN message, which determines its priority and routing."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Payload"}),": Contains up to eight bytes of data, labeled from D0 to D7."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-can-trace",children:"Example CAN Trace"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Timestamp    Tx/Rx    DLC    Address    Data\n10:12:36     Tx      08     0101       30 10 13 14 07 31 D0 D7\n10:12:37     Rx      08     0101       30 00 21 22 D3 00 00 00\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this example:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The first entry is a transmitted message (",(0,r.jsx)(n.code,{children:"Tx"}),") with a DLC of 8 bytes, addressed to ",(0,r.jsx)(n.code,{children:"0101"}),", containing data bytes ",(0,r.jsx)(n.code,{children:"30 10 13 14 07 31 D0 D7"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The second entry is a received message (",(0,r.jsx)(n.code,{children:"Rx"}),") with the same DLC and address, containing data bytes ",(0,r.jsx)(n.code,{children:"30 00 21 22 D3 00 00 00"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"data-length-code-dlc-and-message-addressing",children:"Data Length Code (DLC) and Message Addressing"}),"\n",(0,r.jsx)(n.p,{children:"The DLC field specifies the number of data bytes transmitted in the CAN frame. For UDS over CAN, the DLC is typically set to 8, allowing for up to eight bytes of data per frame. Each data byte is indexed from D0 to D7."}),"\n",(0,r.jsx)(n.h3,{id:"message-addressing",children:"Message Addressing"}),"\n",(0,r.jsx)(n.p,{children:"CAN messages are identified by unique addresses, determining their priority on the network. In UDS communications:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Functional Addressing"}),": Used for broadcast messages intended for multiple ECUs."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physical Addressing"}),": Targets specific ECUs for direct communication."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"transfer-protocol",children:"Transfer Protocol"}),"\n",(0,r.jsx)(n.p,{children:"UDS over CAN employs a multi-frame transfer protocol to handle data exceeding the size of a single CAN frame. This protocol ensures reliable data transmission through structured message segmentation and flow control."}),"\n",(0,r.jsx)(n.h3,{id:"frame-types",children:"Frame Types"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Frame (SF)"}),": Contains complete data within one CAN frame."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"First Frame (FF)"}),": Initiates a multi-frame transfer, indicating the total length of the data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consecutive Frame (CF)"}),": Carries subsequent segments of data in a multi-frame transfer."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flow Control Frame (FC)"}),": Manages the flow of consecutive frames, ensuring orderly transmission."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-of-frame-sequence",children:"Example of Frame Sequence"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"First Frame (FF):\nData: 10 01 30 10 13 14 07 31\n\nFlow Control Frame (FC):\nData: 30 00 21 22 D3 00 00 00\n\nConsecutive Frames (CF):\nData: 21 00 00 00 00 00 00 00\nData: 22 00 00 00 00 00 00 00\n...\n"})}),"\n",(0,r.jsx)(n.h4,{id:"first-frame-ff",children:"First Frame (FF)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Byte 0"}),": Frame type (indicates FF)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bytes 1-2"}),": Total length of the data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bytes 3-7"}),": Initial segment of the data."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"10 01 30 10 13 14 07 31\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"10"}),": Indicates a First Frame."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"01 30"}),": Total data length (in hexadecimal)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"10 13 14 07 31"}),": Initial data segment."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"flow-control-frame-fc",children:"Flow Control Frame (FC)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Byte 0"}),": Flow control type."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Byte 1"}),': Flow status (e.g., 0 for "Continue To Send").']}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bytes 2-3"}),": Block size and separation time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bytes 4-7"}),": Reserved for future use."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"30 00 21 22 D3 00 00 00\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"30"}),": Indicates a Flow Control frame."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"00"}),": Flow status (0 = Continue To Send)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"21 22"}),": Block size and separation time."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"consecutive-frames-cf",children:"Consecutive Frames (CF)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Structure"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Byte 0"}),": Frame type and sequence number."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bytes 1-7"}),": Data segment."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"21 00 00 00 00 00 00 00\n22 00 00 00 00 00 00 00\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"21"}),": Consecutive Frame with sequence number 1."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"22"}),": Consecutive Frame with sequence number 2."]}),"\n",(0,r.jsx)(n.li,{children:"Subsequent frames increment the sequence number accordingly."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"flow-control-mechanism",children:"Flow Control Mechanism"}),"\n",(0,r.jsx)(n.p,{children:"Flow control ensures that the sender transmits consecutive frames at a manageable rate, preventing buffer overflows and ensuring reliable data transfer."}),"\n",(0,r.jsx)(n.h3,{id:"flow-status",children:"Flow Status"}),"\n",(0,r.jsx)(n.p,{children:"The flow status in a Flow Control frame dictates the sender's behavior:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"0x00 (Continue To Send)"}),": The sender can proceed with sending consecutive frames."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"0x01 (Wait)"}),": The sender should pause sending and wait before retrying."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"0x02 (Overflow)"}),": The sender should terminate the transfer due to receiver buffer overflow."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"block-size-and-separation-time",children:"Block Size and Separation Time"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Block Size"}),": Specifies the number of consecutive frames the sender can transmit before waiting for further flow control frames."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Separation Time (STmin)"}),": Defines the minimum time interval between consecutive frames, ensuring the receiver processes frames without delay."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"consecutive-frames-and-data-consumption",children:"Consecutive Frames and Data Consumption"}),"\n",(0,r.jsx)(n.p,{children:"Consecutive frames carry segments of the overall data payload, with each frame containing up to six bytes of actual data:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Consecutive Frame Structure:\n- Byte 0: Frame type and sequence number.\n- Bytes 1-7: Data payload (up to six bytes used for UDS data).\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For instance, in the frame ",(0,r.jsx)(n.code,{children:"21 00 00 00 00 00 00 00"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"21"}),": Frame type (Consecutive Frame) and sequence number (1)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"00 00 00 00 00 00"}),": Data payload."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Only the first six bytes of the data payload are utilized for transferring UDS data, allowing efficient segmentation of larger datasets across multiple frames."}),"\n",(0,r.jsx)(n.h2,{id:"block-size-and-transfer-flow",children:"Block Size and Transfer Flow"}),"\n",(0,r.jsx)(n.p,{children:"The transfer flow is governed by the block size specified in the Flow Control frame. The sender transmits a predefined number of consecutive frames (as per the block size) before pausing to await further flow control instructions. This mechanism ensures that the receiver can process incoming data without being overwhelmed."}),"\n",(0,r.jsx)(n.h3,{id:"transfer-sequence",children:"Transfer Sequence"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sender Initiates Transfer"}),": Sends a First Frame indicating the start of a multi-frame transfer."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Receiver Sends Flow Control"}),": Responds with a Flow Control frame, specifying block size and separation time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sender Sends Consecutive Frames"}),": Transmits consecutive frames based on the specified block size."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flow Control Repeats"}),": After the block size is reached, the sender waits for another Flow Control frame before continuing."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-flow",children:"Example Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Sender:\n- Sends FF: 10 01 30 10 13 14 07 31\n\nReceiver:\n- Sends FC: 30 00 21 22 D3 00 00 00\n\nSender:\n- Sends CF1: 21 00 00 00 00 00 00 00\n- Sends CF2: 22 00 00 00 00 00 00 00\n- ...\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this sequence:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The sender initiates the transfer with a First Frame."}),"\n",(0,r.jsx)(n.li,{children:"The receiver grants permission to continue by sending a Flow Control frame."}),"\n",(0,r.jsx)(n.li,{children:"The sender transmits consecutive frames as per the block size specified."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"timing-considerations",children:"Timing Considerations"}),"\n",(0,r.jsx)(n.p,{children:"Timing is crucial in UDS over CAN to maintain synchronization between sender and receiver, ensuring data integrity and preventing communication bottlenecks."}),"\n",(0,r.jsx)(n.h3,{id:"period-dt-response-time",children:"Period DT (Response Time)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": The period DT defines the expected time interval between consecutive frames."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Configuration"}),": Both sender and receiver must agree on DT to synchronize the transfer rate."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Impact"}),": Properly configured DT ensures that frames are sent and received at intervals that the receiver can handle, preventing data loss."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"response-time-and-message-gap",children:"Response Time and Message Gap"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Response Time"}),": Determines how quickly the receiver responds to incoming frames."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Message Gap"}),": The regular interval at which messages are transmitted, influenced by the period DT."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Importance"}),": Ensures that messages arrive in a steady stream, facilitating smooth data transfer and processing."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"practical-example-of-data-transfer",children:"Practical Example of Data Transfer"}),"\n",(0,r.jsx)(n.p,{children:"Consider a scenario where the sender needs to transfer a large dataset exceeding the capacity of a single CAN frame. The following sequence demonstrates the transfer process:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"First Frame Transmission"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"10 01 30 10 13 14 07 31\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Initiates a multi-frame transfer with a total data length of ",(0,r.jsx)(n.code,{children:"0130"})," (304 bytes)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Flow Control Response"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"30 00 21 22 D3 00 00 00\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Indicates readiness to receive data with a block size of ",(0,r.jsx)(n.code,{children:"21"})," and separation time of ",(0,r.jsx)(n.code,{children:"22 D3"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consecutive Frames Transmission"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"21 00 00 00 00 00 00 00\n22 00 00 00 00 00 00 00\n...\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Transmits consecutive frames with sequence numbers incrementing by one (",(0,r.jsx)(n.code,{children:"21"}),", ",(0,r.jsx)(n.code,{children:"22"}),", etc.)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Flow Control Continuation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"After the block size is reached, the sender awaits another Flow Control frame to continue transmitting the next block of consecutive frames."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This structured approach ensures that large datasets are efficiently segmented and transmitted without overwhelming the receiver, maintaining data integrity throughout the transfer process."}),"\n",(0,r.jsx)(n.h2,{id:"code-snippets",children:"Code Snippets"}),"\n",(0,r.jsx)(n.p,{children:"While the transcript does not provide explicit code examples, the following pseudocode illustrates the handling of UDS over CAN communication based on the discussed principles."}),"\n",(0,r.jsx)(n.h3,{id:"sending-a-first-frame",children:"Sending a First Frame"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def send_first_frame(total_length, data_segment):\n    # Construct First Frame\n    frame_type = 0x10  # First Frame identifier\n    length_high = (total_length >> 8) & 0xFF\n    length_low = total_length & 0xFF\n    data = [frame_type, length_high, length_low] + data_segment[:5]\n    # Pad data to 8 bytes if necessary\n    while len(data) < 8:\n        data.append(0x00)\n    can_message = {\n        'id': 0x0101,\n        'data': data\n    }\n    send_can_message(can_message)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"handling-flow-control-frame",children:"Handling Flow Control Frame"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def handle_flow_control_frame(received_data):\n    frame_type = received_data[0]\n    flow_status = received_data[1]\n    block_size = received_data[2]\n    separation_time = received_data[3]\n    \n    if frame_type != 0x30:\n        raise ValueError("Invalid Flow Control Frame")\n    \n    if flow_status == 0x00:\n        # Continue To Send\n        return block_size, separation_time\n    elif flow_status == 0x01:\n        # Wait\n        wait_separation_time(separation_time)\n        return block_size, separation_time\n    elif flow_status == 0x02:\n        # Overflow\n        raise BufferOverflowError("Receiver buffer overflow")\n    else:\n        raise ValueError("Unknown Flow Status")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"sending-consecutive-frames",children:"Sending Consecutive Frames"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def send_consecutive_frames(data, block_size, separation_time):\n    sequence_number = 1\n    total_frames = len(data) // 6 + (1 if len(data) % 6 else 0)\n    \n    for block in range(0, total_frames, block_size):\n        for i in range(block, min(block + block_size, total_frames)):\n            start = i * 6\n            end = start + 6\n            data_segment = data[start:end]\n            frame_type = 0x20 | (sequence_number & 0x0F)  # Consecutive Frame with sequence number\n            frame_data = [frame_type] + data_segment\n            # Pad data to 8 bytes if necessary\n            while len(frame_data) < 8:\n                frame_data.append(0x00)\n            can_message = {\n                'id': 0x0101,\n                'data': frame_data\n            }\n            send_can_message(can_message)\n            sequence_number = (sequence_number + 1) % 0x10\n            time.sleep(separation_time / 1000.0)  # Convert ms to seconds\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Total data to send (example: 304 bytes)\ntotal_length = 304\ndata = [0x30, 0x10, 0x13, 0x14, 0x07, 0x31] + [0x00] * 298\n\n# Send First Frame\nsend_first_frame(total_length, data)\n\n# Receive Flow Control Frame\nreceived_flow_control = receive_can_message()\nblock_size, separation_time = handle_flow_control_frame(received_flow_control['data'])\n\n# Send Consecutive Frames based on Flow Control\nsend_consecutive_frames(data[5:], block_size, separation_time)\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this pseudocode:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"send_first_frame"})," constructs and sends the First Frame with the initial segment of data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"handle_flow_control_frame"})," processes the received Flow Control frame to determine block size and separation time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"send_consecutive_frames"})," transmits the remaining data in Consecutive Frames, adhering to the block size and separation time constraints."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example Usage"})," demonstrates a complete data transfer sequence, from initiating the First Frame to handling Flow Control and sending Consecutive Frames."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This structured approach ensures reliable and efficient data transmission in UDS over CAN communications, facilitating advanced diagnostics and vehicle control operations."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>l});var i=s(96540);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);