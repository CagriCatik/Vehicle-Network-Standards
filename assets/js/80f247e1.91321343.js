"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[88998],{39328:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"AUTOSAR/rte/architecture","title":"Layered Framework Overview","description":"AUTOSAR (AUTomotive Open System ARchitecture) provides a standardized software framework for automotive systems. The architecture is designed with modularity, scalability, and abstraction to support development across multiple ECUs and applications. This document provides an in-depth explanation of the key layers and their functionalities.","source":"@site/docs/AUTOSAR/03_rte/02_architecture.md","sourceDirName":"AUTOSAR/03_rte","slug":"/AUTOSAR/rte/architecture","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AUTOSAR/03_rte/02_architecture.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"autosarSidebar","previous":{"title":"Runtime Environment: The Switchboard Operator in AUTOSAR","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/role_rte"},"next":{"title":"RTE as Runtime Environment for Runnables","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/rte_runnables"}}');var s=r(74848),t=r(28453);const l={},o="Layered Framework Overview",a={},c=[{value:"<strong>1. Overview of AUTOSAR Architecture</strong>",id:"1-overview-of-autosar-architecture",level:2},{value:"<strong>Key Objectives</strong>",id:"key-objectives",level:3},{value:"<strong>2. Layered Architecture</strong>",id:"2-layered-architecture",level:2},{value:"<strong>2.1 Application Layer</strong>",id:"21-application-layer",level:3},{value:"Example:",id:"example",level:4},{value:"<strong>2.2 Runtime Environment (RTE)</strong>",id:"22-runtime-environment-rte",level:3},{value:"Example:",id:"example-1",level:4},{value:"<strong>2.3 Services Layer</strong>",id:"23-services-layer",level:3},{value:"<strong>2.4 ECU Abstraction Layer</strong>",id:"24-ecu-abstraction-layer",level:3},{value:"<strong>2.5 Microcontroller Abstraction Layer (MCAL)</strong>",id:"25-microcontroller-abstraction-layer-mcal",level:3},{value:"Example:",id:"example-2",level:4},{value:"<strong>2.6 Microcontroller</strong>",id:"26-microcontroller",level:3},{value:"<strong>2.7 Complex Drivers</strong>",id:"27-complex-drivers",level:3},{value:"<strong>3. Middleware Communication</strong>",id:"3-middleware-communication",level:2},{value:"<strong>4. Advantages of AUTOSAR Layered Architecture</strong>",id:"4-advantages-of-autosar-layered-architecture",level:2},{value:"<strong>5. Example Workflow</strong>",id:"5-example-workflow",level:2},{value:"<strong>Use Case: Interior Lighting Control</strong>",id:"use-case-interior-lighting-control",level:3},{value:"<strong>6. Summary</strong>",id:"6-summary",level:2},{value:"Key Takeaways:",id:"key-takeaways",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"layered-framework-overview",children:"Layered Framework Overview"})}),"\n",(0,s.jsx)(n.p,{children:"AUTOSAR (AUTomotive Open System ARchitecture) provides a standardized software framework for automotive systems. The architecture is designed with modularity, scalability, and abstraction to support development across multiple ECUs and applications. This document provides an in-depth explanation of the key layers and their functionalities."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"1-overview-of-autosar-architecture",children:(0,s.jsx)(n.strong,{children:"1. Overview of AUTOSAR Architecture"})}),"\n",(0,s.jsx)(n.h3,{id:"key-objectives",children:(0,s.jsx)(n.strong,{children:"Key Objectives"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Task"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Develop software components that are ",(0,s.jsx)(n.strong,{children:"independent of ECU mapping"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Enable reusability and portability across different platforms."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Functionality"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Serve as middleware to provide ",(0,s.jsx)(n.strong,{children:"communication services"})," within and between ECUs (intra- and inter-ECU communication)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"2-layered-architecture",children:(0,s.jsx)(n.strong,{children:"2. Layered Architecture"})}),"\n",(0,s.jsx)(n.p,{children:"The AUTOSAR architecture is organized into several layers, each with specific responsibilities. This layered design ensures separation of concerns and facilitates easier development and maintenance."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"21-application-layer",children:(0,s.jsx)(n.strong,{children:"2.1 Application Layer"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Contains application-level ",(0,s.jsx)(n.strong,{children:"Software Components (SWCs)"})," that implement the system\u2019s functionality."]}),"\n",(0,s.jsx)(n.li,{children:"Examples include lighting control, door state monitoring, and powertrain management."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Features"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["SWCs communicate via the ",(0,s.jsx)(n.strong,{children:"Runtime Environment (RTE)"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Hardware-independent design enables reusability."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"An SWC to monitor door state:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"void MonitorDoorState(void) {\n    boolean doorState;\n    Rte_Read_LeftDoor_DoorOpen(&doorState);\n    // Process the door state\n}\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"22-runtime-environment-rte",children:(0,s.jsx)(n.strong,{children:"2.2 Runtime Environment (RTE)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Acts as middleware between the Application Layer and lower layers."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Responsibilities"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Manages communication between SWCs (intra-ECU)."}),"\n",(0,s.jsx)(n.li,{children:"Facilitates inter-ECU communication through underlying layers."}),"\n",(0,s.jsx)(n.li,{children:"Provides task scheduling and execution."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-1",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"Routing signals from a sensor to an actuator:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"Rte_Read_Sensor_DoorOpen(&doorState);\nRte_Write_Actuator_LightControl(brightness);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"23-services-layer",children:(0,s.jsx)(n.strong,{children:"2.3 Services Layer"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provides system-wide services required by the Application Layer and RTE."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Responsibilities"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Memory management (NVM)."}),"\n",(0,s.jsx)(n.li,{children:"Diagnostic services."}),"\n",(0,s.jsx)(n.li,{children:"Communication stack services (CAN, LIN, FlexRay)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Features"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Abstracts hardware details for higher layers."}),"\n",(0,s.jsx)(n.li,{children:"Ensures system reliability through services like watchdog monitoring."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"24-ecu-abstraction-layer",children:(0,s.jsx)(n.strong,{children:"2.4 ECU Abstraction Layer"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Standardizes the interface to the hardware, making the upper layers hardware-independent."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Responsibilities"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provides access to peripherals and devices (e.g., ADC, PWM, timers)."}),"\n",(0,s.jsx)(n.li,{children:"Interfaces with the Microcontroller Abstraction Layer (MCAL)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Features"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Supports seamless integration of different microcontrollers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"25-microcontroller-abstraction-layer-mcal",children:(0,s.jsx)(n.strong,{children:"2.5 Microcontroller Abstraction Layer (MCAL)"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provides a direct interface to the microcontroller hardware."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Responsibilities"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implements drivers for microcontroller peripherals (e.g., GPIO, ADC, UART)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Features"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Hardware-specific layer ensures efficient communication with the microcontroller."}),"\n",(0,s.jsx)(n.li,{children:"Abstracts the complexity of hardware interaction for higher layers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-2",children:"Example:"}),"\n",(0,s.jsx)(n.p,{children:"Reading an ADC value:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"uint16_t adcValue = Adc_ReadChannel(ADC_CHANNEL_1);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"26-microcontroller",children:(0,s.jsx)(n.strong,{children:"2.6 Microcontroller"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The physical hardware executing the software stack."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Key Components"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Includes the CPU, memory, and onboard peripherals."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Interfaces with the MCAL for direct communication with the AUTOSAR stack."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"27-complex-drivers",children:(0,s.jsx)(n.strong,{children:"2.7 Complex Drivers"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Enable direct hardware access for special functionalities that cannot be abstracted by the MCAL."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Cases"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"High-performance or safety-critical operations requiring low latency."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"3-middleware-communication",children:(0,s.jsx)(n.strong,{children:"3. Middleware Communication"})}),"\n",(0,s.jsx)(n.p,{children:"AUTOSAR middleware handles all communication, ensuring that data flows seamlessly between layers:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Intra-ECU Communication"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"SWCs on the same ECU exchange data through the RTE."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inter-ECU Communication"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Data is routed through the Services Layer using communication protocols like CAN, LIN, or Ethernet."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"4-advantages-of-autosar-layered-architecture",children:(0,s.jsx)(n.strong,{children:"4. Advantages of AUTOSAR Layered Architecture"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modularity"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Separates functionality into distinct layers, simplifying development and debugging."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reusability"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Enables reuse of SWCs across projects and platforms."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware Independence"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Abstracts hardware details, allowing software to run on different microcontrollers."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Supports systems of varying complexity, from simple ECUs to advanced multi-ECU networks."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintainability"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Changes in one layer (e.g., hardware) do not affect higher layers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"5-example-workflow",children:(0,s.jsx)(n.strong,{children:"5. Example Workflow"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case-interior-lighting-control",children:(0,s.jsx)(n.strong,{children:"Use Case: Interior Lighting Control"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Input"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A door sensor detects the door is open and sends the ",(0,s.jsx)(n.code,{children:"DoorOpen"})," signal to the RTE."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Processing"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["An SWC in the Application Layer processes the ",(0,s.jsx)(n.code,{children:"DoorOpen"})," signal."]}),"\n",(0,s.jsx)(n.li,{children:"Determines the brightness level for the interior light."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Output"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The processed brightness value is sent to the actuator through the RTE."}),"\n",(0,s.jsx)(n.li,{children:"The actuator adjusts the light intensity via a PWM signal controlled by the MCAL."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"6-summary",children:(0,s.jsx)(n.strong,{children:"6. Summary"})}),"\n",(0,s.jsx)(n.p,{children:"The AUTOSAR layered architecture is designed to provide a robust framework for automotive software development. Its modularity, hardware abstraction, and communication services enable efficient development, integration, and maintenance of complex automotive systems."}),"\n",(0,s.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Application Layer"}),": Implements the functionality."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RTE"}),": Middleware facilitating communication and scheduling."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Services Layer"}),": Provides system-wide services."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ECU and Microcontroller Abstraction Layers"}),": Standardize hardware interaction."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MCAL"}),": Interfaces directly with microcontroller hardware."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex Drivers"}),": Handle hardware-specific tasks requiring low latency."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var i=r(96540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);