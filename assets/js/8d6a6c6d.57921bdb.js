"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[9479],{12721:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>d,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"AUTOSAR/Methodik/entwicklungsphasen","title":"AUTOSAR-Methodik","description":"Einleitung","source":"@site/docs/AUTOSAR/02_Methodik/01_entwicklungsphasen.md","sourceDirName":"AUTOSAR/02_Methodik","slug":"/AUTOSAR/Methodik/entwicklungsphasen","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/Methodik/entwicklungsphasen","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AUTOSAR/02_Methodik/01_entwicklungsphasen.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"autosarSidebar","previous":{"title":"\xdcbersicht","permalink":"/Vehicle-Network-Standards/docs/category/\xfcbersicht-1"},"next":{"title":"austauschformate","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/Methodik/austauschformate"}}');var r=i(74848),s=i(28453);const d={},l="AUTOSAR-Methodik",o={},u=[{value:"Einleitung",id:"einleitung",level:2},{value:"Methodik",id:"methodik",level:2},{value:"Architektur",id:"architektur",level:2},{value:"Konfiguration des Steuerger\xe4ts",id:"konfiguration-des-steuerger\xe4ts",level:2},{value:"Anwendung",id:"anwendung",level:2},{value:"Fazit",id:"fazit",level:2}];function a(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"autosar-methodik",children:"AUTOSAR-Methodik"})}),"\n",(0,r.jsx)(n.h2,{id:"einleitung",children:"Einleitung"}),"\n",(0,r.jsx)(n.p,{children:"AUTOSAR (AUTomotive Open System ARchitecture) ist eine standardisierte Plattform f\xfcr die Entwicklung und Konfiguration von Steuerger\xe4tesoftware in der Automobilindustrie. Dieses Tutorial bietet eine detaillierte Einf\xfchrung in die AUTOSAR-Methodik, Architektur und die Konfiguration von Steuerger\xe4ten. Wir werden die einzelnen Schritte kritisch beleuchten und sicherstellen, dass jede Information korrekt und pr\xe4zise vermittelt wird."}),"\n",(0,r.jsx)(n.h2,{id:"methodik",children:"Methodik"}),"\n",(0,r.jsx)(n.p,{children:"Die AUTOSAR-Methodik unterteilt den Entwicklungsprozess von Steuerger\xe4tesoftware in klar definierte Aktionen und standardisiert den Datenaustausch zwischen den Entwicklungspartnern. Dies wird durch den Einsatz von XML-Dateien erreicht, die eine einheitliche Kommunikationsbasis bieten."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Systementwurf"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Architektur der Anwendung"}),": Der erste Schritt besteht darin, die Systemarchitektur festzulegen. Dies umfasst die Definition von Softwarekomponenten (SWCs) und deren Zuordnung zu den Steuerger\xe4ten. Dabei wird auch die Netzwerkkommunikation bestimmt."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"System Description"}),": Das Ergebnis des Systementwurfs ist die System Description, eine AUTOSAR XML-Datei. Diese Datei bildet die Grundlage f\xfcr den spezifischen ECU Extract of System Description, der f\xfcr jedes Steuerger\xe4t erzeugt wird."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"architektur",children:"Architektur"}),"\n",(0,r.jsx)(n.p,{children:"Die Architektur in AUTOSAR basiert auf einem mehrschichtigen Modell, das die Trennung von Applikations- und Basissoftware erm\xf6glicht."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Software-Komponenten (SWCs)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"SWCs sind modular und bieten definierte Schnittstellen, die in den SWC Descriptions beschrieben werden."}),"\n",(0,r.jsx)(n.li,{children:"Diese Modularit\xe4t erlaubt es, die SWCs unabh\xe4ngig voneinander zu entwickeln und zu testen, was die Zusammenarbeit zwischen OEMs und Tier1-Zulieferern erleichtert."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"RTE (Runtime Environment)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Die RTE stellt die Verbindung zwischen den SWCs und der Basissoftware her. Sie wird f\xfcr jedes Steuerger\xe4t spezifisch generiert, basierend auf der System Description und der ECU Configuration Description."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"konfiguration-des-steuerger\xe4ts",children:"Konfiguration des Steuerger\xe4ts"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementierung der SWCs"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In dieser Phase werden die SWCs gem\xe4\xdf den in den SWC Descriptions festgelegten Schnittstellen implementiert."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Konfiguration von BSW und RTE"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Die Basissoftware (BSW) und die RTE werden konfiguriert. Dies beinhaltet die Anpassung der BSW-Module an die spezifischen Anforderungen des Projekts."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"ECU Configuration Description"}),": Das Ergebnis der Konfiguration ist eine ECU Configuration Description (AUTOSAR XML-Datei), die auf den ECU Extract of System Description abgestimmt ist."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Code-Generierung"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Basierend auf der ECU Configuration Description wird die Basissoftware durch den Einsatz von Codegeneratoren erzeugt oder angepasst."}),"\n",(0,r.jsx)(n.li,{children:"Auch die RTE wird spezifisch f\xfcr das jeweilige Steuerger\xe4t generiert."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"anwendung",children:"Anwendung"}),"\n",(0,r.jsx)(n.p,{children:"Die Applikationsentwicklung kann unabh\xe4ngig von der Konfiguration der Steuerger\xe4te betrachtet werden."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SWC Descriptions"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Die Schnittstellen der SWCs werden in den SWC Descriptions beschrieben. Dies erm\xf6glicht eine unabh\xe4ngige Implementierung und Testung der SWCs."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Zusammenspiel der Komponenten"}),": Durch die standardisierten Schnittstellen k\xf6nnen Applikationskomponenten von verschiedenen Entwicklungsparteien (OEMs und Tier1) einfach integriert und miteinander kombiniert werden."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"fazit",children:"Fazit"}),"\n",(0,r.jsx)(n.p,{children:"Die AUTOSAR-Methodik bietet eine strukturierte und standardisierte Vorgehensweise f\xfcr die Entwicklung von Steuerger\xe4tesoftware. Durch die klare Trennung von Systementwurf, Konfiguration und Applikationsentwicklung wird eine hohe Flexibilit\xe4t und Wiederverwendbarkeit der Softwarekomponenten erreicht. Die Verwendung von XML-Dateien f\xfcr den Datenaustausch gew\xe4hrleistet eine einheitliche und transparente Kommunikation zwischen allen Beteiligten im Entwicklungsprozess."}),"\n",(0,r.jsx)(n.p,{children:"Dieses Tutorial hat die wichtigsten Aspekte der AUTOSAR-Methodik detailliert und wissenschaftlich fundiert erl\xe4utert. Bei der Implementierung in der Praxis ist es entscheidend, die Vorgaben und Standards von AUTOSAR genau zu beachten, um die gew\xfcnschten Vorteile in Bezug auf Modularit\xe4t, Wiederverwendbarkeit und Effizienz zu erzielen."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>l});var t=i(96540);const r={},s=t.createContext(r);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);