"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[46879],{79685:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"OTA/target-device/doip-external","title":"DoIP - Connection to External Tester","description":"Diagnostics over Internet Protocol (DoIP) is a communication protocol standardized under ISO 13400, designed to facilitate diagnostic communication between vehicle Electronic Control Units (ECUs) and external diagnostic testers over Ethernet networks. DoIP enhances the efficiency and speed of diagnostic operations by leveraging the high bandwidth and flexibility of IP-based networks. This documentation delves into the intricacies of establishing and managing DoIP connections to external testers within an AUTOSAR framework, providing advanced users with comprehensive technical insights and practical code implementations.","source":"@site/docs/OTA/07_target-device/05_doip-external.md","sourceDirName":"OTA/07_target-device","slug":"/OTA/target-device/doip-external","permalink":"/Vehicle-Network-Standards/docs/OTA/target-device/doip-external","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/OTA/07_target-device/05_doip-external.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"otaSidebar","previous":{"title":"UDS over Ethernet","permalink":"/Vehicle-Network-Standards/docs/OTA/target-device/doip"},"next":{"title":"Bootloader in Electronic Control Units","permalink":"/Vehicle-Network-Standards/docs/OTA/target-device/bootloader"}}');var t=i(74848),r=i(28453);const o={},a="DoIP - Connection to External Tester",c={},d=[{value:"AUTOSAR Layer Architecture for DoIP",id:"autosar-layer-architecture-for-doip",level:2},{value:"AUTOSAR Layer Composition",id:"autosar-layer-composition",level:3},{value:"DoIP Integration within AUTOSAR",id:"doip-integration-within-autosar",level:3},{value:"DoIP Communication Stack",id:"doip-communication-stack",level:2},{value:"Layered Communication Flow",id:"layered-communication-flow",level:3},{value:"Connection Establishment Process",id:"connection-establishment-process",level:2},{value:"Step 1: Vehicle Discovery and Announcement via UDP",id:"step-1-vehicle-discovery-and-announcement-via-udp",level:3},{value:"Step 2: Vehicle Identification Message Handling",id:"step-2-vehicle-identification-message-handling",level:3},{value:"Step 3: Routing Activation Request via TCP",id:"step-3-routing-activation-request-via-tcp",level:3},{value:"Step 4: Diagnostic Communication",id:"step-4-diagnostic-communication",level:3},{value:"Connection Termination",id:"connection-termination",level:2},{value:"Summary of Communication Flow",id:"summary-of-communication-flow",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"doip---connection-to-external-tester",children:"DoIP - Connection to External Tester"})}),"\n",(0,t.jsx)(n.p,{children:"Diagnostics over Internet Protocol (DoIP) is a communication protocol standardized under ISO 13400, designed to facilitate diagnostic communication between vehicle Electronic Control Units (ECUs) and external diagnostic testers over Ethernet networks. DoIP enhances the efficiency and speed of diagnostic operations by leveraging the high bandwidth and flexibility of IP-based networks. This documentation delves into the intricacies of establishing and managing DoIP connections to external testers within an AUTOSAR framework, providing advanced users with comprehensive technical insights and practical code implementations."}),"\n",(0,t.jsx)(n.h2,{id:"autosar-layer-architecture-for-doip",children:"AUTOSAR Layer Architecture for DoIP"}),"\n",(0,t.jsx)(n.p,{children:"Understanding the AUTOSAR (AUTomotive Open System ARchitecture) layered architecture is crucial for implementing DoIP effectively. The architecture delineates clear separation of concerns, enabling modular and scalable development. Below is a detailed examination of the relevant layers and their interactions in the context of DoIP."}),"\n",(0,t.jsx)(n.h3,{id:"autosar-layer-composition",children:"AUTOSAR Layer Composition"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Application Layer"}),": Houses the diagnostic services and application-specific functionalities."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runtime Environment (RTE)"}),": Facilitates communication between the application layer and the underlying services."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Basic Software (BSW)"}),": Comprises various modules that provide essential services, including communication stacks and hardware abstraction."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Microcontroller Abstraction Layer (MCAL)"}),": Interfaces directly with the hardware, providing low-level drivers."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"doip-integration-within-autosar",children:"DoIP Integration within AUTOSAR"}),"\n",(0,t.jsx)(n.p,{children:"Within the AUTOSAR architecture, DoIP is integrated primarily within the BSW. The key components involved in DoIP communication include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Kante Module"}),": Acts as an interface between the DoIP protocol and the rest of the AUTOSAR stack."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pre-Router"}),": Manages routing of diagnostic messages across different communication channels."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CAN Driver and CAN Transport Protocol (CAN TP)"}),": Facilitate communication over the Controller Area Network (CAN) bus."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Socket Adapter"}),": Bridges DoIP communication with socket-based networking."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frame Types Module"}),": Defines and manages different frame formats used in DoIP."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ethernet Interface and Driver"}),": Handle physical and data link layer operations over Ethernet."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The interaction between these components ensures seamless data transmission between the ECUs and external diagnostic testers."}),"\n",(0,t.jsx)(n.h2,{id:"doip-communication-stack",children:"DoIP Communication Stack"}),"\n",(0,t.jsx)(n.p,{children:"The DoIP communication stack leverages both UDP and TCP protocols to establish and manage diagnostic sessions. Understanding the roles and functionalities of these protocols within the stack is essential for advanced diagnostics and troubleshooting."}),"\n",(0,t.jsx)(n.h3,{id:"layered-communication-flow",children:"Layered Communication Flow"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DoIP Module"}),": Initiates communication and manages protocol-specific operations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Socket Adapter"}),": Facilitates the use of standard socket APIs for network communication."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frame Types Module"}),": Handles the construction and parsing of DoIP-specific frame structures."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ethernet Interface"}),": Manages the physical Ethernet connection, including MAC addressing and frame transmission."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ethernet Driver"}),": Provides low-level access to the Ethernet hardware, ensuring efficient data transfer."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This layered approach ensures modularity and flexibility, allowing each component to be developed and maintained independently."}),"\n",(0,t.jsx)(n.h2,{id:"connection-establishment-process",children:"Connection Establishment Process"}),"\n",(0,t.jsx)(n.p,{children:"Establishing a DoIP connection between an external tester and an ECU involves a series of well-defined steps. This process ensures secure and reliable communication, enabling effective diagnostic operations."}),"\n",(0,t.jsx)(n.h3,{id:"step-1-vehicle-discovery-and-announcement-via-udp",children:"Step 1: Vehicle Discovery and Announcement via UDP"}),"\n",(0,t.jsx)(n.p,{children:"The initial phase involves the external tester broadcasting a discovery request to identify available vehicles on the network."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// UDP discovery request example\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <arpa/inet.h>\n\n#define DISCOVERY_PORT 13400\n#define DISCOVERY_MESSAGE "VehicleDiscoveryRequest"\n\nint main() {\n    int sockfd;\n    struct sockaddr_in servaddr;\n    \n    // Create UDP socket\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    \n    memset(&servaddr, 0, sizeof(servaddr));\n    \n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(DISCOVERY_PORT);\n    servaddr.sin_addr.s_addr = inet_addr("255.255.255.255"); // Broadcast address\n    \n    // Send discovery message\n    sendto(sockfd, DISCOVERY_MESSAGE, strlen(DISCOVERY_MESSAGE), 0, \n           (struct sockaddr*)&servaddr, sizeof(servaddr));\n    \n    close(sockfd);\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Characteristics of UDP in DoIP:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Connectionless"}),": No persistent connection is established; ideal for initial discovery."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Non-reliable"}),": No guarantee of message delivery, ordering, or duplication protection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Primarily used for broadcasting discovery and announcement messages."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-2-vehicle-identification-message-handling",children:"Step 2: Vehicle Identification Message Handling"}),"\n",(0,t.jsx)(n.p,{children:"Upon receiving a discovery request, the ECU evaluates the identification message to determine whether to respond based on predefined criteria such as MAC address or Vehicle Identification Number (VIN)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// Vehicle identification response example\n#include <stdio.h>\n#include <string.h>\n#include <arpa/inet.h>\n\n#define IDENTIFICATION_PORT 13400\n#define RESPONSE_MESSAGE "VehicleDiscoveryResponse"\n#define VALID_MAC "00:1A:2B:3C:4D:5E"\n#define VALID_VIN "1HGCM82633A004352"\n\nint main() {\n    int sockfd;\n    struct sockaddr_in cliaddr;\n    char buffer[1024];\n    socklen_t len = sizeof(cliaddr);\n    \n    // Create UDP socket\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    \n    // Bind to discovery port\n    struct sockaddr_in servaddr;\n    memset(&servaddr, 0, sizeof(servaddr));\n    \n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = INADDR_ANY;\n    servaddr.sin_port = htons(IDENTIFICATION_PORT);\n    \n    bind(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr));\n    \n    // Receive discovery request\n    recvfrom(sockfd, buffer, sizeof(buffer), 0, (struct sockaddr*)&cliaddr, &len);\n    \n    // Parse and validate identification message\n    // Assume buffer contains JSON with ID type and value\n    // Example: {"id_type":"MAC","id_value":"00:1A:2B:3C:4D:5E"}\n    // Pseudocode for parsing and validation\n    \n    char id_type[10];\n    char id_value[30];\n    // Parse JSON (implementation omitted for brevity)\n    \n    if ((strcmp(id_type, "MAC") == 0 && strcmp(id_value, VALID_MAC) == 0) ||\n        (strcmp(id_type, "VIN") == 0 && strcmp(id_value, VALID_VIN) == 0)) {\n        // Send response\n        sendto(sockfd, RESPONSE_MESSAGE, strlen(RESPONSE_MESSAGE), 0, \n               (struct sockaddr*)&cliaddr, len);\n    }\n    \n    close(sockfd);\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Identification Criteria:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MAC Address or VIN"}),": The ECU compares the received ID against its stored MAC address or VIN based on configuration."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Response Logic"}),": A response is sent only if the received ID matches the ECU's stored ID; otherwise, no response is issued, effectively closing the connection attempt."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-3-routing-activation-request-via-tcp",children:"Step 3: Routing Activation Request via TCP"}),"\n",(0,t.jsx)(n.p,{children:"After successful discovery and identification, the external tester initiates a reliable connection using TCP to activate routing for subsequent diagnostic communication."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// TCP routing activation example\n#include <stdio.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define ROUTING_PORT 13400\n#define ACTIVATION_REQUEST "RoutingActivationRequest"\n\nint main() {\n    int sockfd;\n    struct sockaddr_in servaddr;\n    \n    // Create TCP socket\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    memset(&servaddr, 0, sizeof(servaddr));\n    \n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(ROUTING_PORT);\n    servaddr.sin_addr.s_addr = inet_addr("192.168.1.100"); // ECU IP address\n    \n    // Connect to ECU\n    connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr));\n    \n    // Send routing activation request\n    send(sockfd, ACTIVATION_REQUEST, strlen(ACTIVATION_REQUEST), 0);\n    \n    // Receive activation response\n    char buffer[1024];\n    int n = recv(sockfd, buffer, sizeof(buffer), 0);\n    buffer[n] = \'\\0\';\n    printf("Received: %s\\n", buffer);\n    \n    // Proceed with diagnostic communication if activation is successful\n    \n    close(sockfd);\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Characteristics of TCP in DoIP:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reliable Connection"}),": Ensures ordered and error-checked delivery of messages."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistent Connection"}),": Maintains an open channel for ongoing diagnostic operations, such as flashing or DTC (Diagnostic Trouble Code) activities."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),": Utilized for routing activation and sustained diagnostic communication following successful discovery."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-4-diagnostic-communication",children:"Step 4: Diagnostic Communication"}),"\n",(0,t.jsx)(n.p,{children:"Once the routing is activated, the external tester can send diagnostic requests over the established TCP connection. The ECU processes these requests and responds accordingly."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// Diagnostic request example over TCP\n#include <stdio.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define DIAGNOSTIC_PORT 13400\n#define DIAGNOSTIC_REQUEST "ReadDTCRequest"\n\nint main() {\n    int sockfd;\n    struct sockaddr_in servaddr;\n    \n    // Create TCP socket\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    memset(&servaddr, 0, sizeof(servaddr));\n    \n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(DIAGNOSTIC_PORT);\n    servaddr.sin_addr.s_addr = inet_addr("192.168.1.100"); // ECU IP address\n    \n    // Connect to ECU\n    connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr));\n    \n    // Send diagnostic request\n    send(sockfd, DIAGNOSTIC_REQUEST, strlen(DIAGNOSTIC_REQUEST), 0);\n    \n    // Receive diagnostic response\n    char buffer[1024];\n    int n = recv(sockfd, buffer, sizeof(buffer), 0);\n    buffer[n] = \'\\0\';\n    printf("Received DTCs: %s\\n", buffer);\n    \n    close(sockfd);\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Diagnostic Operations:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Request Types"}),": Includes standard diagnostic services such as reading DTCs, ECU reprogramming, and sensor calibration."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Response Handling"}),": ECUs respond with either positive acknowledgments or negative responses based on the validity and feasibility of the requested operation."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"connection-termination",children:"Connection Termination"}),"\n",(0,t.jsx)(n.p,{children:"After completing the diagnostic session, the TCP connection must be gracefully terminated to release resources and ensure network stability."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'// Connection termination example\n#include <stdio.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define TERMINATION_MESSAGE "TerminateConnection"\n\nint main() {\n    int sockfd;\n    struct sockaddr_in servaddr;\n    \n    // Create TCP socket\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    \n    memset(&servaddr, 0, sizeof(servaddr));\n    \n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(13400);\n    servaddr.sin_addr.s_addr = inet_addr("192.168.1.100"); // ECU IP address\n    \n    // Connect to ECU\n    connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr));\n    \n    // Send termination message\n    send(sockfd, TERMINATION_MESSAGE, strlen(TERMINATION_MESSAGE), 0);\n    \n    // Optionally receive acknowledgment\n    char buffer[1024];\n    int n = recv(sockfd, buffer, sizeof(buffer), 0);\n    if (n > 0) {\n        buffer[n] = \'\\0\';\n        printf("Termination Acknowledged: %s\\n", buffer);\n    }\n    \n    // Close socket\n    close(sockfd);\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Termination Process:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initiation"}),": Typically initiated by the ECU upon completion of diagnostic activities, but can also be requested by the external tester."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graceful Shutdown"}),": Ensures all pending communications are completed before closing the connection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Release"}),": Frees up network and system resources, allowing for future diagnostic sessions without conflicts."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary-of-communication-flow",children:"Summary of Communication Flow"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Discovery"}),": External tester broadcasts a UDP discovery request."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Identification"}),": ECU validates the request and responds if identifiers match."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Activation"}),": External tester establishes a TCP connection and sends a routing activation request."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Diagnostic Session"}),": Ongoing diagnostic requests and responses are managed over the TCP connection."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Termination"}),": The session is gracefully closed, terminating the TCP connection."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"Establishing a DoIP connection to an external tester within an AUTOSAR framework involves meticulous coordination across multiple layers and protocols. By leveraging UDP for initial discovery and TCP for reliable, persistent communication, DoIP ensures efficient and secure diagnostic operations. The provided code snippets offer practical implementations for each stage of the connection process, serving as a valuable reference for advanced users aiming to develop or enhance DoIP-based diagnostic solutions."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(96540);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);