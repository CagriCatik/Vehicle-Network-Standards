"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[49162],{83164:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"AUTOSAR/rte/rte_runnables","title":"Runnables","description":"In the AUTOSAR (AUTomotive Open System ARchitecture) framework, Runnables are the fundamental executable units that perform specific functions within Software Components (SWCs). Managed by the Runtime Environment (RTE), Runnables are triggered based on predefined events and facilitate seamless communication between SWCs, the Operating System (OS), and the Basic Software (BSW). This chapter provides an in-depth exploration of Runnables, their mapping, execution, communication mechanisms, customization, and the benefits they offer within the AUTOSAR ecosystem.","source":"@site/docs/AUTOSAR/03_rte/03_rte_runnables.md","sourceDirName":"AUTOSAR/03_rte","slug":"/AUTOSAR/rte/rte_runnables","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/rte_runnables","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AUTOSAR/03_rte/03_rte_runnables.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"autosarSidebar","previous":{"title":"Layered Framework Overview","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/architecture"},"next":{"title":"Communication Interface","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/rte_com_interface"}}');var t=i(74848),r=i(28453);const a={},o="Runnables",l={},d=[{value:"1. RTE Overview",id:"1-rte-overview",level:2},{value:"Key Characteristics",id:"key-characteristics",level:3},{value:"2. Mapping and Execution of Runnables",id:"2-mapping-and-execution-of-runnables",level:2},{value:"2.1 Mapping Runnables to OS Tasks",id:"21-mapping-runnables-to-os-tasks",level:3},{value:"Example: Dimmer SWC",id:"example-dimmer-swc",level:4},{value:"Configuration Snippet:",id:"configuration-snippet",level:4},{value:"2.2 RTE Event Triggers",id:"22-rte-event-triggers",level:3},{value:"Common RTE Events",id:"common-rte-events",level:4},{value:"Example Workflow",id:"example-workflow",level:4},{value:"3. Communication Through RTE",id:"3-communication-through-rte",level:2},{value:"3.1 Sender/Receiver Communication",id:"31-senderreceiver-communication",level:3},{value:"Example",id:"example",level:4},{value:"3.2 Client/Server Communication",id:"32-clientserver-communication",level:3},{value:"Example",id:"example-1",level:4},{value:"4. RTE Customization",id:"4-rte-customization",level:2},{value:"Key Considerations",id:"key-considerations",level:3},{value:"Example Configuration Snippet:",id:"example-configuration-snippet",level:4},{value:"5. RTE Code Generation",id:"5-rte-code-generation",level:2},{value:"Components of RTE Code Generation",id:"components-of-rte-code-generation",level:3},{value:"Example Code Snippet:",id:"example-code-snippet",level:4},{value:"6. Key Benefits of the RTE",id:"6-key-benefits-of-the-rte",level:2},{value:"7. Use Case: Interior Lighting System",id:"7-use-case-interior-lighting-system",level:2},{value:"Workflow",id:"workflow",level:3},{value:"Diagram:",id:"diagram",level:4},{value:"Combined Code Example:",id:"combined-code-example",level:4},{value:"8. Summary",id:"8-summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"runnables",children:"Runnables"})}),"\n",(0,t.jsxs)(n.p,{children:["In the AUTOSAR (AUTomotive Open System ARchitecture) framework, ",(0,t.jsx)(n.strong,{children:"Runnables"})," are the fundamental executable units that perform specific functions within Software Components (SWCs). Managed by the ",(0,t.jsx)(n.strong,{children:"Runtime Environment (RTE)"}),", Runnables are triggered based on predefined events and facilitate seamless communication between SWCs, the Operating System (OS), and the Basic Software (BSW). This chapter provides an in-depth exploration of Runnables, their mapping, execution, communication mechanisms, customization, and the benefits they offer within the AUTOSAR ecosystem."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"1-rte-overview",children:"1. RTE Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"Runtime Environment (RTE)"})," serves as the middleware layer in AUTOSAR, orchestrating the interaction between SWCs, the OS, and the BSW. Its primary responsibility is to manage Runnables by ensuring they are executed efficiently and in response to relevant events. Understanding the RTE's role is crucial for effectively leveraging Runnables in automotive software development."]}),"\n",(0,t.jsx)(n.h3,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Configurable Middleware"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": The RTE allows for the mapping of Runnables to specific OS tasks during the configuration phase."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implication"}),": This flexibility ensures that Runnables are executed within the appropriate context, adhering to system priorities and requirements."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event-Based Execution"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Runnables are triggered by events predefined in the RTE configuration."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implication"}),": Enables responsive and efficient execution of tasks based on system and external stimuli."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task Configuration"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Defines task priorities, alarms, and scheduling mechanisms to optimize execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implication"}),": Ensures that critical tasks receive the necessary resources and are executed in a timely manner."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Customizable"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Each Electronic Control Unit (ECU) possesses a unique RTE tailored to the specific SWCs it hosts."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implication"}),": Facilitates modularity and scalability across different hardware configurations and application domains."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"2-mapping-and-execution-of-runnables",children:"2. Mapping and Execution of Runnables"}),"\n",(0,t.jsx)(n.p,{children:"Runnables are central to the execution flow within AUTOSAR applications. Proper mapping and execution strategies are essential for achieving optimal system performance and reliability."}),"\n",(0,t.jsx)(n.h3,{id:"21-mapping-runnables-to-os-tasks",children:"2.1 Mapping Runnables to OS Tasks"}),"\n",(0,t.jsx)(n.p,{children:"During the system design phase, each Runnable is mapped to an OS task. This mapping is based on several factors, including priority levels, execution frequency, and triggering events."}),"\n",(0,t.jsx)(n.h4,{id:"example-dimmer-swc",children:"Example: Dimmer SWC"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runnables"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AP_Init"}),": Initializes the dimmer system at startup."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AP_Dim"}),": Adjusts brightness based on external signals (e.g., ",(0,t.jsx)(n.code,{children:"Contact"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mapping"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AP_Init"}),": Mapped to an initialization task with high priority to ensure the dimmer system is ready promptly."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AP_Dim"}),": Mapped to an event-based task that is triggered by the ",(0,t.jsx)(n.code,{children:"Contact"})," signal, allowing dynamic brightness adjustments."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"configuration-snippet",children:"Configuration Snippet:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<Task id="Task_DimmerInit" priority="High">\n    <RunnableRef>AP_Init</RunnableRef>\n</Task>\n<Task id="Task_DimmerControl" priority="Medium" trigger="ContactSignal">\n    <RunnableRef>AP_Dim</RunnableRef>\n</Task>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"22-rte-event-triggers",children:"2.2 RTE Event Triggers"}),"\n",(0,t.jsx)(n.p,{children:"Runnables are activated in response to specific events defined within the RTE configuration. These events determine when and how Runnables are executed, ensuring that system behavior aligns with real-time requirements."}),"\n",(0,t.jsx)(n.h4,{id:"common-rte-events",children:"Common RTE Events"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Event"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Description"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Example Use Case"})})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Init"})}),(0,t.jsx)(n.td,{children:"Triggered during system initialization."}),(0,t.jsxs)(n.td,{children:["SWC initialization (e.g., ",(0,t.jsx)(n.code,{children:"AP_Init"}),")."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"TimingEvent"})}),(0,t.jsx)(n.td,{children:"Periodic trigger based on a timer."}),(0,t.jsx)(n.td,{children:"Sensor data processing every 20ms."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"DataReceivedEvent"})," (S/R)"]}),(0,t.jsx)(n.td,{children:"Triggered when new data is received."}),(0,t.jsxs)(n.td,{children:["Adjusting brightness based on ",(0,t.jsx)(n.code,{children:"Contact"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"DataReceiveErrorEvent"})," (S/R)"]}),(0,t.jsx)(n.td,{children:"Triggered on data reception failure."}),(0,t.jsx)(n.td,{children:"Diagnostic monitoring and error reporting."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.strong,{children:"OperationInvokedEvent"})," (C/S)"]}),(0,t.jsx)(n.td,{children:"Triggered when a server operation is called."}),(0,t.jsx)(n.td,{children:"Handling diagnostic service requests."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"ModeSwitchEvent"})}),(0,t.jsx)(n.td,{children:"Triggered when a mode switch occurs."}),(0,t.jsx)(n.td,{children:"Switching between normal and diagnostic modes."})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"example-workflow",children:"Example Workflow"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"Contact"})," signal is received by the RTE from a sensor."]}),"\n",(0,t.jsxs)(n.li,{children:["The RTE identifies the associated Runnable (",(0,t.jsx)(n.code,{children:"AP_Dim"}),") mapped to the ",(0,t.jsx)(n.code,{children:"Contact"})," event."]}),"\n",(0,t.jsxs)(n.li,{children:["The RTE triggers the ",(0,t.jsx)(n.code,{children:"AP_Dim"})," Runnable, initiating the brightness adjustment process."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"3-communication-through-rte",children:"3. Communication Through RTE"}),"\n",(0,t.jsxs)(n.p,{children:["Effective communication is paramount in complex automotive systems. The RTE facilitates this by managing data exchange between SWCs and between SWCs and the underlying OS/BSW. AUTOSAR supports two primary communication paradigms: ",(0,t.jsx)(n.strong,{children:"Sender/Receiver (S/R)"})," and ",(0,t.jsx)(n.strong,{children:"Client/Server (C/S)"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"31-senderreceiver-communication",children:"3.1 Sender/Receiver Communication"}),"\n",(0,t.jsx)(n.p,{children:"In the Sender/Receiver model, SWCs exchange data through ports managed by the RTE. This model is ideal for scenarios where data flow is straightforward and does not require complex interactions."}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sensor SWC"})," sends the ",(0,t.jsx)(n.code,{children:"DoorOpen"})," signal:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"Std_ReturnType status = Rte_Write_Sensor_DoorOpen(doorState);\nif (status != E_OK) {\n    // Handle write failure\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Actuator SWC"})," reads the ",(0,t.jsx)(n.code,{children:"DoorOpen"})," signal:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"boolean doorState;\nStd_ReturnType status = Rte_Read_Actuator_DoorOpen(&doorState);\nif (status == E_OK) {\n    // Actuate based on doorState\n} else {\n    // Handle read failure\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"32-clientserver-communication",children:"3.2 Client/Server Communication"}),"\n",(0,t.jsx)(n.p,{children:"The Client/Server model is suited for more complex interactions where SWCs need to invoke operations or services provided by other components. This paradigm supports request-response mechanisms essential for functionalities like diagnostics."}),"\n",(0,t.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Client SWC"})," invokes a diagnostic operation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"DiagnosticDataType diagnosticData;\nStd_ReturnType status = Rte_Call_DiagnosticService_ReadData(&diagnosticData);\nif (status == E_OK) {\n    // Process diagnosticData\n} else {\n    // Handle invocation failure\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Server SWC"})," implements the diagnostic operation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"Std_ReturnType DiagnosticService_ReadData(DiagnosticDataType* data) {\n    // Populate diagnostic data\n    *data = GetDiagnosticInfo();\n    return E_OK;\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"4-rte-customization",children:"4. RTE Customization"}),"\n",(0,t.jsx)(n.p,{children:"Customization of the RTE is essential to align it with the specific requirements of each ECU and its hosted SWCs. This involves configuring task priorities, event mappings, and ensuring that the RTE accurately reflects the ECU's role within the system."}),"\n",(0,t.jsx)(n.h3,{id:"key-considerations",children:"Key Considerations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ECU-Specific Configuration"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Each ECU possesses a unique RTE configuration tailored to its specific set of SWCs and system responsibilities."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),": Define distinct mappings and event triggers based on the ECU's functional role (e.g., lighting control, engine management)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task Configuration"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Establishes the priorities and scheduling parameters for tasks associated with Runnables."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),": Assign higher priorities to critical Runnables to ensure they are executed promptly, while less critical tasks are assigned lower priorities."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event Mapping"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Associates Runnables with specific events to control their triggering mechanisms."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),": Ensure that each Runnable is linked to the appropriate event type (e.g., ",(0,t.jsx)(n.code,{children:"TimingEvent"}),", ",(0,t.jsx)(n.code,{children:"DataReceivedEvent"}),") to maintain system responsiveness and reliability."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-configuration-snippet",children:"Example Configuration Snippet:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<RunnableMapping>\n    <Runnable id="AP_Init">\n        <TaskRef>Task_DimmerInit</TaskRef>\n        <EventRef>Init</EventRef>\n    </Runnable>\n    <Runnable id="AP_Dim">\n        <TaskRef>Task_DimmerControl</TaskRef>\n        <EventRef>DataReceivedEvent_Contact</EventRef>\n    </Runnable>\n</RunnableMapping>\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"5-rte-code-generation",children:"5. RTE Code Generation"}),"\n",(0,t.jsx)(n.p,{children:"The RTE is responsible for generating executable code based on the system's configuration. This automated process ensures consistency and adherence to the defined mappings and event triggers."}),"\n",(0,t.jsx)(n.h3,{id:"components-of-rte-code-generation",children:"Components of RTE Code Generation"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Task Routines"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Code that executes Runnables within the context of OS tasks."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"void Rte_Task_DimmerInit(void) {\n    // Execute initialization Runnable\n    AP_Init();\n}\n\nvoid Rte_Task_DimmerControl(void) {\n    // Execute dimming Runnable upon Contact event\n    AP_Dim();\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event Handlers"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Logic that listens for and responds to events by triggering the associated Runnables."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"void Event_Handler_Contact(void) {\n    // Trigger the AP_Dim Runnable when Contact signal is received\n    AP_Dim();\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Communication Interfaces"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Description"}),": Code that manages data exchange through ports, ensuring that Sender/Receiver and Client/Server communications are handled correctly."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"Std_ReturnType Rte_Write_Sensor_DoorOpen(boolean doorState) {\n    // Code to write the DoorOpen signal to the RTE port\n    // ...\n    return E_OK;\n}\n\nStd_ReturnType Rte_Call_DiagnosticService_ReadData(DiagnosticDataType* data) {\n    // Code to invoke the DiagnosticService_ReadData operation\n    // ...\n    return DiagnosticService_ReadData(data);\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-code-snippet",children:"Example Code Snippet:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// Runnables Execution within OS Task\nvoid Rte_Task_DimmerControl(void) {\n    // Check if Contact event has triggered the Runnable\n    if (ContactEventTriggered()) {\n        AP_Dim();\n    }\n}\n\n// Event Handler for Contact Signal\nvoid Event_Handler_Contact(void) {\n    // Trigger the AP_Dim Runnable when Contact signal is received\n    AP_Dim();\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"6-key-benefits-of-the-rte",children:"6. Key Benefits of the RTE"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"Runtime Environment (RTE)"})," offers numerous advantages that enhance the development and operation of automotive software systems. Its capabilities contribute significantly to the overall efficiency, reliability, and scalability of the AUTOSAR architecture."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware Abstraction"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": SWCs remain independent of the underlying hardware, allowing developers to focus on application logic without concerning themselves with hardware specifics."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Impact"}),": Facilitates easier migration and scalability across different hardware platforms."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Supports both simple and complex systems, accommodating multiple ECUs and numerous SWCs seamlessly."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Impact"}),": Enables the development of scalable automotive systems that can evolve with increasing functional requirements."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Interoperability"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Standardized communication protocols and interfaces ensure consistent and reliable data exchange between SWCs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Impact"}),": Reduces integration challenges and enhances the reliability of inter-component communications."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deterministic Behavior"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Ensures predictable execution of critical tasks through prioritized scheduling and event-based triggers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Impact"}),": Essential for safety-critical applications where timing and reliability are paramount."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modularity and Reusability"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Encourages the development of modular SWCs that can be reused across different projects and platforms."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Impact"}),": Reduces development time and costs while promoting a clean and maintainable codebase."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ease of Configuration and Maintenance"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefit"}),": Simplifies the configuration process through standardized tools and methodologies."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Impact"}),": Enhances maintainability and facilitates easier system updates and troubleshooting."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"7-use-case-interior-lighting-system",children:"7. Use Case: Interior Lighting System"}),"\n",(0,t.jsxs)(n.p,{children:["To illustrate the practical application of Runnables within the AUTOSAR framework, consider the following use case focused on an ",(0,t.jsx)(n.strong,{children:"Interior Lighting System"}),". This example demonstrates how Runnables interact with each other and with the RTE to achieve the desired functionality."]}),"\n",(0,t.jsx)(n.h3,{id:"workflow",children:"Workflow"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SWC1: Door Monitoring"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Function"}),": Monitors the state of the vehicle's doors."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runnable"}),": ",(0,t.jsx)(n.code,{children:"MonitorDoorState"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action"}),": Sends a ",(0,t.jsx)(n.code,{children:"Contact"})," signal when a door is opened or closed."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// SWC1: Door Monitoring\nvoid MonitorDoorState(void) {\n    boolean doorState = ReadDoorSensor();\n    Std_ReturnType status = Rte_Write_Sensor_Contact(doorState);\n    if (status != E_OK) {\n        // Handle write failure\n    }\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"SWC2: Dimmer"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Functions"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AP_Init"}),": Initializes the dimmer system at startup."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AP_Dim"}),": Adjusts brightness based on the ",(0,t.jsx)(n.code,{children:"Contact"})," signal."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// SWC2: Dimmer\nvoid AP_Init(void) {\n    // Initialize dimmer hardware\n    InitializeDimmingHardware();\n}\n\nvoid AP_Dim(void) {\n    boolean doorOpen;\n    Std_ReturnType status = Rte_Read_Sensor_Contact(&doorOpen);\n    if (status == E_OK) {\n        uint8_t brightness = doorOpen ? 75 : 0; // 75% if door open, else off\n        Std_ReturnType writeStatus = Rte_Write_Actuator_Lighting(brightness);\n        if (writeStatus != E_OK) {\n            // Handle write failure\n        }\n    } else {\n        // Handle read failure\n    }\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"RTE Configuration"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mapping"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AP_Init"})," is mapped to an initialization task triggered during system startup."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AP_Dim"})," is mapped to an event-based task triggered by the ",(0,t.jsx)(n.code,{children:"Contact"})," signal."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<RunnableMapping>\n    <Runnable id="AP_Init">\n        <TaskRef>Task_DimmerInit</TaskRef>\n        <EventRef>Init</EventRef>\n    </Runnable>\n    <Runnable id="AP_Dim">\n        <TaskRef>Task_DimmerControl</TaskRef>\n        <EventRef>DataReceivedEvent_Contact</EventRef>\n    </Runnable>\n</RunnableMapping>\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Execution Flow"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Initialization"}),":","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["System starts, triggering the ",(0,t.jsx)(n.code,{children:"Init"})," event."]}),"\n",(0,t.jsxs)(n.li,{children:["RTE executes ",(0,t.jsx)(n.code,{children:"AP_Init"})," Runnable to initialize the dimmer system."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runtime Operation"}),":","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["A door is opened, triggering the ",(0,t.jsx)(n.code,{children:"DataReceivedEvent_Contact"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["RTE executes ",(0,t.jsx)(n.code,{children:"AP_Dim"})," Runnable to adjust the interior lighting based on the door state."]}),"\n",(0,t.jsx)(n.li,{children:"The actuator receives the brightness value and adjusts the lights accordingly."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"diagram",children:"Diagram:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-plaintext",children:"[Door Sensor] --\x3e [RTE] --\x3e [SWC1: MonitorDoorState] --\x3e [RTE] --\x3e [SWC2: AP_Dim] --\x3e [RTE] --\x3e [Actuator: Lighting Control] --\x3e [MCAL] --\x3e [Interior Lights]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"combined-code-example",children:"Combined Code Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// SWC1: Door Monitoring\nvoid MonitorDoorState(void) {\n    boolean doorState = ReadDoorSensor();\n    Std_ReturnType status = Rte_Write_Sensor_Contact(doorState);\n    if (status != E_OK) {\n        // Handle write failure\n    }\n}\n\n// SWC2: Dimmer\nvoid AP_Init(void) {\n    InitializeDimmingHardware();\n}\n\nvoid AP_Dim(void) {\n    boolean doorOpen;\n    Std_ReturnType status = Rte_Read_Sensor_Contact(&doorOpen);\n    if (status == E_OK) {\n        uint8_t brightness = doorOpen ? 75 : 0;\n        Std_ReturnType writeStatus = Rte_Write_Actuator_Lighting(brightness);\n        if (writeStatus != E_OK) {\n            // Handle write failure\n        }\n    } else {\n        // Handle read failure\n    }\n}\n\n// Actuator Control via MCAL\nvoid AdjustLightIntensity(void) {\n    uint8_t brightness;\n    Std_ReturnType status = Rte_Read_Actuator_Lighting(&brightness);\n    if (status == E_OK) {\n        uint16_t dutyCycle = (brightness * MAX_PWM_VALUE) / 100;\n        Pwm_SetDutyCycle(PWM_CHANNEL_LIGHT, dutyCycle);\n    } else {\n        // Handle read failure\n    }\n}\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"8-summary",children:"8. Summary"}),"\n",(0,t.jsx)(n.p,{children:"Runnables are the smallest executable units within the AUTOSAR framework, orchestrated by the RTE to perform specific functions in response to defined events. This chapter has delved into the intricacies of Runnables, covering their mapping to OS tasks, execution triggers, communication mechanisms, customization, and the benefits they provide."}),"\n",(0,t.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Runnable Management"}),": The RTE efficiently maps and triggers Runnables based on system events, ensuring timely and prioritized execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Communication Paradigms"}),": AUTOSAR supports both ",(0,t.jsx)(n.strong,{children:"Sender/Receiver"})," and ",(0,t.jsx)(n.strong,{children:"Client/Server"})," communication models, enabling flexible data exchange between SWCs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Customization"}),": Each ECU's RTE is uniquely configured to reflect its specific set of SWCs and system roles, promoting modularity and scalability."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Code Generation"}),": Automated RTE code generation ensures consistency and adherence to defined configurations, reducing manual coding errors."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Benefits"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Hardware Abstraction"}),": Runnables operate independently of hardware specifics, facilitating portability and scalability."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability and Interoperability"}),": The RTE supports complex systems with multiple ECUs and SWCs, ensuring standardized communication and execution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deterministic Behavior"}),": Predictable execution patterns are maintained through prioritized scheduling and event-based triggers, crucial for safety-critical applications."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By effectively managing Runnables, the RTE plays a pivotal role in the AUTOSAR architecture, enabling the development of robust, efficient, and scalable automotive software systems."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h1,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["This comprehensive documentation has provided an extensive overview of ",(0,t.jsx)(n.strong,{children:"Runnables"})," within the AUTOSAR framework, highlighting their critical role in automotive software development. By understanding how Runnables are managed, mapped, and executed through the RTE, developers can design modular, scalable, and efficient automotive systems. Whether you are a beginner seeking foundational knowledge or an advanced practitioner aiming to refine your expertise, this guide offers valuable insights into leveraging Runnables to their fullest potential within the AUTOSAR ecosystem."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(96540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);