"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[20936],{61119:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>u});const i=JSON.parse('{"id":"SOVA/core-concepts-soa/ziel_soa","title":"Ziele der serviceorientierten Architektur","description":"Die Entwicklung einer service-orientierten Fahrzeugarchitektur verfolgt mehrere Ziele, von denen das Hauptziel die","source":"@site/docs/SOVA/03_core-concepts-soa/08_ziel_soa.md","sourceDirName":"SOVA/03_core-concepts-soa","slug":"/SOVA/core-concepts-soa/ziel_soa","permalink":"/Vehicle-Network-Standards/docs/SOVA/core-concepts-soa/ziel_soa","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/SOVA/03_core-concepts-soa/08_ziel_soa.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"sovaSidebar","previous":{"title":"Allgemeines architektonisches Muster f\xfcr serviceorientierte  Kommunikation","permalink":"/Vehicle-Network-Standards/docs/SOVA/core-concepts-soa/muster_soa"},"next":{"title":"Technical Frameworks and Protocols","permalink":"/Vehicle-Network-Standards/docs/category/technical-frameworks-and-protocols"}}');var t=r(74848),s=r(28453);const o={},c="Ziele der serviceorientierten Architektur",a={},u=[];function d(e){const n={h1:"h1",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"ziele-der-serviceorientierten-architektur",children:"Ziele der serviceorientierten Architektur"})}),"\n",(0,t.jsx)(n.p,{children:"Die Entwicklung einer service-orientierten Fahrzeugarchitektur verfolgt mehrere Ziele, von denen das Hauptziel die\nEntkopplung des Zugangs zu Fahrzeugressourcen \xfcber die Onboard Vehicle API als zentrale abstrahierende\nSchnittstelle im Fahrzeug ist. Diese Entkopplung wird mithilfe von Services realisiert, die \xfcber spezielle Client\nServer-Schnittstellen, die Methodenaufrufe erm\xf6glichen, einen generischen Zugang zu den Fahrzeugressourcen\ngew\xe4hren. Dabei bleibt die Fahrzeugressource selbst unver\xe4ndert, sie kann jedoch je nach den W\xfcnschen des\nClients, der eine Anfrage stellt, unterschiedliche Zust\xe4nde annehmen, um die gew\xfcnschten Funktionen zu erf\xfcllen.\nDie Implementierung generischer Signale zur Steuerung und Nutzung von Fahrzeugressourcen stellt jedoch eine\nkomplexe Aufgabe dar und birgt zahlreiche Herausforderungen. Zum Beispiel muss ber\xfccksichtigt werden, wie mit\nkonkurrierenden Anfragen von mehreren Clients auf eine Ressource umgegangen wird.\nUm solche Fragen zu beantworten, besch\xe4ftigt sich die Forschung intensiv mit der Entwicklung von Design Patterns\nund Richtlinien f\xfcr die SOA-Architektur und das Design der Onboard Vehicle API. Dies umfasst die Gestaltung der\nSchnittstellen f\xfcr die Services der Onboard Vehicle API sowie die Auswahl geeigneter Technologien und Protokolle\nals Datenaustauschformat zwischen dem Service Provider und den anfragenden Clients, um die spezifischen\nAnforderungen im Bereich der Automobilindustrie zu erf\xfcllen. Dabei ist eine sorgf\xe4ltige Ber\xfccksichtigung von\nSicherheit, Skalierbarkeit und Effizienz von entscheidender Bedeutung, um eine zuverl\xe4ssige und leistungsf\xe4hige\nservice-orientierte Fahrzeugarchitektur zu entwickeln."})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>c});var i=r(96540);const t={},s=i.createContext(t);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);