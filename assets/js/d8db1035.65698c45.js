"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[43930],{76162:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"AUTOSAR/rte/queued","title":"Sender/Receiver Communication: Queued","description":"This documentation focuses on Queued Sender/Receiver Communication within AUTOSAR, which uses an event-based semantic mechanism (isQueued=true) for data exchange. This approach relies on receive queues for managing multiple data instances, providing flexibility in scenarios requiring event-based communication.","source":"@site/docs/AUTOSAR/03_rte/08_queued.md","sourceDirName":"AUTOSAR/03_rte","slug":"/AUTOSAR/rte/queued","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/queued","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AUTOSAR/03_rte/08_queued.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"autosarSidebar","previous":{"title":"Sender/Receiver Communication: Buffered","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/buffered"},"next":{"title":"Sender/Receiver Communication: Data Element Invalidation","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/rte/sender-receiver-com"}}');var r=s(74848),t=s(28453);const d={},l="Sender/Receiver Communication: Queued",a={},c=[{value:"<strong>1. Key Features of Queued Communication</strong>",id:"1-key-features-of-queued-communication",level:2},{value:"<strong>1.1 Event Semantic</strong>",id:"11-event-semantic",level:3},{value:"<strong>1.2 Data Consistency</strong>",id:"12-data-consistency",level:3},{value:"<strong>1.3 Timeout Handling</strong>",id:"13-timeout-handling",level:3},{value:"<strong>2. Communication Workflow</strong>",id:"2-communication-workflow",level:2},{value:"<strong>2.1 Send Operation</strong>",id:"21-send-operation",level:3},{value:"Code Example:",id:"code-example",level:4},{value:"<strong>2.2 Receive Operation</strong>",id:"22-receive-operation",level:3},{value:"Code Example:",id:"code-example-1",level:4},{value:"<strong>3. Function Prototypes</strong>",id:"3-function-prototypes",level:2},{value:"<strong>Rte_Send</strong>",id:"rte_send",level:3},{value:"Example:",id:"example",level:4},{value:"<strong>Rte_Receive</strong>",id:"rte_receive",level:3},{value:"Example:",id:"example-1",level:4},{value:"<strong>4. Advantages of Queued Communication</strong>",id:"4-advantages-of-queued-communication",level:2},{value:"<strong>5. Limitations</strong>",id:"5-limitations",level:2},{value:"<strong>6. Use Cases</strong>",id:"6-use-cases",level:2},{value:"<strong>7. Summary</strong>",id:"7-summary",level:2},{value:"<strong>Key Takeaways:</strong>",id:"key-takeaways",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"senderreceiver-communication-queued",children:"Sender/Receiver Communication: Queued"})}),"\n",(0,r.jsxs)(n.p,{children:["This documentation focuses on ",(0,r.jsx)(n.strong,{children:"Queued Sender/Receiver Communication"})," within AUTOSAR, which uses an ",(0,r.jsx)(n.strong,{children:"event-based semantic"})," mechanism (",(0,r.jsx)(n.code,{children:"isQueued=true"}),") for data exchange. This approach relies on receive queues for managing multiple data instances, providing flexibility in scenarios requiring event-based communication."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"1-key-features-of-queued-communication",children:(0,r.jsx)(n.strong,{children:"1. Key Features of Queued Communication"})}),"\n",(0,r.jsx)(n.h3,{id:"11-event-semantic",children:(0,r.jsx)(n.strong,{children:"1.1 Event Semantic"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Polling Receive:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The receiver actively checks the queue for new data."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Waiting Receive:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The receiver blocks and waits for data until a timeout occurs (if defined)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Queue Management:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["RTE reads data from a ",(0,r.jsx)(n.strong,{children:"dedicated receive queue"}),", ensuring ordered processing of events."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"12-data-consistency",children:(0,r.jsx)(n.strong,{children:"1.2 Data Consistency"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each data instance in the queue is handled as a separate event, ensuring no overwrites or loss of intermediate data values."}),"\n",(0,r.jsx)(n.li,{children:"Data remains available in the queue until consumed."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"13-timeout-handling",children:(0,r.jsx)(n.strong,{children:"1.3 Timeout Handling"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Waiting receive operations can be configured with a timeout to ensure system responsiveness."}),"\n",(0,r.jsx)(n.li,{children:"Enables robust handling of real-time systems where delays in data reception could occur."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"2-communication-workflow",children:(0,r.jsx)(n.strong,{children:"2. Communication Workflow"})}),"\n",(0,r.jsx)(n.h3,{id:"21-send-operation",children:(0,r.jsx)(n.strong,{children:"2.1 Send Operation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The sender Runnable uses the ",(0,r.jsx)(n.code,{children:"Rte_Send"})," API to push data into the queue."]}),"\n",(0,r.jsx)(n.li,{children:"The RTE appends the data to the tail of the queue."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"code-example",children:"Code Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"Std_ReturnType Rte_Send_<p>_<d>(IN <DataType> data);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"22-receive-operation",children:(0,r.jsx)(n.strong,{children:"2.2 Receive Operation"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The receiver Runnable retrieves data from the queue using the ",(0,r.jsx)(n.code,{children:"Rte_Receive"})," API."]}),"\n",(0,r.jsx)(n.li,{children:"The RTE pops data from the head of the queue."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"code-example-1",children:"Code Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"Std_ReturnType Rte_Receive_<p>_<d>(OUT <DataType> *data);\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"3-function-prototypes",children:(0,r.jsx)(n.strong,{children:"3. Function Prototypes"})}),"\n",(0,r.jsx)(n.h3,{id:"rte_send",children:(0,r.jsx)(n.strong,{children:"Rte_Send"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"Std_ReturnType Rte_Send_<p>_<d>(IN <DataType> data);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"data"}),": The value to send into the queue."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Usage:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Called by the sender Runnable to enqueue data for the receiver."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Return:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"E_OK"}),": Successful operation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"E_NOT_OK"}),": Queue is full, and data cannot be enqueued."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example",children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"Rte_Send_SensorModule_Temperature(25);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"rte_receive",children:(0,r.jsx)(n.strong,{children:"Rte_Receive"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"Std_ReturnType Rte_Receive_<p>_<d>(OUT <DataType> *data);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"data"}),": Pointer to the variable where dequeued data will be stored."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Usage:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Called by the receiver Runnable to retrieve the next queued data instance."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Return:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"E_OK"}),": Successful operation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"E_NOT_OK"}),": Queue is empty."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-1",children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"int32_t receivedTemp;\nStd_ReturnType status = Rte_Receive_SensorModule_Temperature(&receivedTemp);\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"4-advantages-of-queued-communication",children:(0,r.jsx)(n.strong,{children:"4. Advantages of Queued Communication"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Event-Based Communication:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ideal for systems requiring event-driven data handling."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lossless Data Transmission:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prevents overwrites and ensures every data instance is processed."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Multiple data instances can be stored and processed sequentially."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"5-limitations",children:(0,r.jsx)(n.strong,{children:"5. Limitations"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Queue Management Overhead:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Additional memory and processing overhead due to queue handling."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Queue Size Constraints:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Limited by the size of the receive queue; excessive data can cause overflow."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"6-use-cases",children:(0,r.jsx)(n.strong,{children:"6. Use Cases"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sensor Data Streams:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Applications where periodic sensor readings must be processed as discrete events."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interrupt-Driven Systems:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Event-driven communication for scenarios like button presses or fault notifications."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"7-summary",children:(0,r.jsx)(n.strong,{children:"7. Summary"})}),"\n",(0,r.jsxs)(n.p,{children:["Queued Sender/Receiver Communication in AUTOSAR provides an efficient mechanism for handling ",(0,r.jsx)(n.strong,{children:"event-based data exchange"}),". By employing ",(0,r.jsx)(n.strong,{children:"dedicated queues"})," for data transmission, this approach ensures lossless communication and supports robust event handling."]}),"\n",(0,r.jsx)(n.h3,{id:"key-takeaways",children:(0,r.jsx)(n.strong,{children:"Key Takeaways:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["APIs include ",(0,r.jsx)(n.code,{children:"Rte_Send"})," and ",(0,r.jsx)(n.code,{children:"Rte_Receive"})," for enqueueing and dequeueing data."]}),"\n",(0,r.jsx)(n.li,{children:"Ensures ordered, event-based communication."}),"\n",(0,r.jsx)(n.li,{children:"Suitable for scenarios requiring discrete event processing."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This mechanism is indispensable in real-time systems requiring robust and deterministic communication. For further details, refer to the AUTOSAR specification or consult your system architect."})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var i=s(96540);const r={},t=i.createContext(r);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);