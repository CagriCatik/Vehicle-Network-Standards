"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[21573],{61398:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>d,metadata:()=>t,toc:()=>f});const t=JSON.parse('{"id":"CAN/CAN-FD/geaendertes-bitstuffing","title":"Bitstuffing bei CAN und CAN FD: Ein umfassendes Tutorial","description":"Das Bitstuffing ist eine zentrale Technik im Controller Area Network (CAN), die dazu dient, Synchronisationsprobleme zu vermeiden und eine zuverl\xe4ssige Daten\xfcbertragung sicherzustellen. Sowohl im klassischen CAN-Protokoll als auch im CAN Flexible Data-Rate (CAN FD) Protokoll wird das Bitstuffing angewendet, jedoch mit unterschiedlichen Regeln und Bereichen. Dieser Teil bietet eine detaillierte Erkl\xe4rung der Bitstuffing-Mechanismen bei CAN und CAN FD, einschlie\xdflich der Behandlung von Stuffbits im CRC-Feld.","source":"@site/docs/CAN/06_CAN-FD/11_geaendertes-bitstuffing.md","sourceDirName":"CAN/06_CAN-FD","slug":"/CAN/CAN-FD/geaendertes-bitstuffing","permalink":"/Vehicle-Network-Standards/docs/CAN/CAN-FD/geaendertes-bitstuffing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/CAN/06_CAN-FD/11_geaendertes-bitstuffing.md","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{},"sidebar":"canSidebar","previous":{"title":"Mehr Daten bei gleichbleibender Sicherheit","permalink":"/Vehicle-Network-Standards/docs/CAN/CAN-FD/gleichbleibende-sicherheit"}}');var s=n(74848),r=n(28453);const d={},l="Bitstuffing bei CAN und CAN FD: Ein umfassendes Tutorial",c={},f=[{value:"Bitstuffing im klassischen CAN",id:"bitstuffing-im-klassischen-can",level:2},{value:"Bitstuffing bei CAN FD",id:"bitstuffing-bei-can-fd",level:2},{value:"Bitstuffing im CRC-Feld bei CAN FD",id:"bitstuffing-im-crc-feld-bei-can-fd",level:2},{value:"Keine Stuffbits nach dem CRC-Feld",id:"keine-stuffbits-nach-dem-crc-feld",level:2}];function a(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"bitstuffing-bei-can-und-can-fd-ein-umfassendes-tutorial",children:"Bitstuffing bei CAN und CAN FD: Ein umfassendes Tutorial"})}),"\n",(0,s.jsx)(i.p,{children:"Das Bitstuffing ist eine zentrale Technik im Controller Area Network (CAN), die dazu dient, Synchronisationsprobleme zu vermeiden und eine zuverl\xe4ssige Daten\xfcbertragung sicherzustellen. Sowohl im klassischen CAN-Protokoll als auch im CAN Flexible Data-Rate (CAN FD) Protokoll wird das Bitstuffing angewendet, jedoch mit unterschiedlichen Regeln und Bereichen. Dieser Teil bietet eine detaillierte Erkl\xe4rung der Bitstuffing-Mechanismen bei CAN und CAN FD, einschlie\xdflich der Behandlung von Stuffbits im CRC-Feld."}),"\n",(0,s.jsx)(i.h2,{id:"bitstuffing-im-klassischen-can",children:"Bitstuffing im klassischen CAN"}),"\n",(0,s.jsx)(i.p,{children:'Im klassischen CAN-Protokoll wird Bitstuffing angewendet, um die Takt-Synchronisation zwischen Sender und Empf\xe4nger aufrechtzuerhalten. Die Grundregel des Bitstuffings lautet: Nach jeweils f\xfcnf aufeinanderfolgenden Bits mit gleichem Wert (entweder 0 oder 1) wird ein komplement\xe4res Bit eingef\xfcgt. Dieses eingef\xfcgte Bit wird als "Stuffbit" bezeichnet.'}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Beispiel:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Wenn eine Nachricht die Bitfolge ",(0,s.jsx)(i.code,{children:"111110"})," enth\xe4lt, wird ein Stuffbit eingef\xfcgt, wodurch die Folge ",(0,s.jsx)(i.code,{children:"1111101"})," entsteht."]}),"\n",(0,s.jsx)(i.li,{children:"Wichtig ist, dass die Stuffbits nicht in die Berechnung der Pr\xfcfsumme (CRC) einflie\xdfen."}),"\n",(0,s.jsx)(i.li,{children:"Dies bedeutet, dass beim Empfangen der Nachricht die Stuffbits entfernt werden, bevor die CRC-Pr\xfcfung durchgef\xfchrt wird."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"bitstuffing-bei-can-fd",children:"Bitstuffing bei CAN FD"}),"\n",(0,s.jsx)(i.p,{children:"Das CAN FD-Protokoll erweitert das klassische CAN-Protokoll um h\xf6here Datenraten und gr\xf6\xdfere Datenfelder. Daher sind die Regeln f\xfcr das Bitstuffing bei CAN FD etwas anders und spezifischer."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Bitstuffing-Regel:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Stuffbits werden ab dem Start of Frame (SOF) eingef\xfcgt."}),"\n",(0,s.jsx)(i.li,{children:"Das Bitstuffing endet mit dem Ende des Datenfeldes."}),"\n",(0,s.jsx)(i.li,{children:"Nach dem Ende des Datenfeldes wird die Anzahl der eingef\xfcgten Stuffbits (Modulo 8) berechnet und ein zus\xe4tzliches Parit\xe4tsbit eingef\xfcgt."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"CRC-Berechnung bei CAN FD:"})}),"\n",(0,s.jsx)(i.p,{children:"Der sendende Knoten berechnet die Pr\xfcfsumme (CRC), einschlie\xdflich der bis zu diesem Punkt eingef\xfcgten Stuffbits. Dies unterscheidet sich vom klassischen CAN, wo die Stuffbits nicht in die CRC-Berechnung einflie\xdfen."}),"\n",(0,s.jsx)(i.h2,{id:"bitstuffing-im-crc-feld-bei-can-fd",children:"Bitstuffing im CRC-Feld bei CAN FD"}),"\n",(0,s.jsx)(i.p,{children:"Zus\xe4tzlich zur allgemeinen Bitstuffing-Regel bei CAN FD gibt es spezielle Regeln f\xfcr das CRC-Feld:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Das CRC-Feld beginnt immer mit einem Stuffbit."}),"\n",(0,s.jsx)(i.li,{children:"Nach jeweils vier weiteren CRC-Feld-Bits wird ein weiteres Stuffbit eingef\xfcgt, unabh\xe4ngig davon, ob die Bits gleichnamig sind oder nicht."}),"\n",(0,s.jsx)(i.li,{children:"Der Wert eines CRC-Stuffbits ist komplement\xe4r zu seinem Vorg\xe4ngerbit."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Beispiel:"})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Angenommen, das CRC-Feld beginnt mit der Bitfolge ",(0,s.jsx)(i.code,{children:"1101"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Es wird ein Stuffbit eingef\xfcgt, wodurch die Folge ",(0,s.jsx)(i.code,{children:"11011"})," entsteht."]}),"\n",(0,s.jsxs)(i.li,{children:["Nach vier weiteren Bits, z.B. ",(0,s.jsx)(i.code,{children:"1000"}),", wird ein weiteres Stuffbit eingef\xfcgt, was ",(0,s.jsx)(i.code,{children:"10001"})," ergibt."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"keine-stuffbits-nach-dem-crc-feld",children:"Keine Stuffbits nach dem CRC-Feld"}),"\n",(0,s.jsx)(i.p,{children:"Nach dem CRC-Feld werden, wie beim klassischen CAN, keine weiteren Stuffbits mehr eingef\xfcgt. Das bedeutet, dass der Rest des Frames (Acknowledge Slot, End of Frame, etc.) ohne zus\xe4tzliche Stuffbits gesendet wird."})]})}function u(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>d,x:()=>l});var t=n(96540);const s={},r=t.createContext(s);function d(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);