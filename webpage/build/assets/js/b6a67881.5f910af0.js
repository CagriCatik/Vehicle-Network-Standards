"use strict";(self.webpackChunkvns=self.webpackChunkvns||[]).push([[4734],{85671:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>d,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"AUTOSAR/Grundlagen/04_3_autosar","title":"04_3_autosar","description":"Einleitung","source":"@site/docs/AUTOSAR/01_Grundlagen/04_3_autosar.md","sourceDirName":"AUTOSAR/01_Grundlagen","slug":"/AUTOSAR/Grundlagen/04_3_autosar","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/Grundlagen/04_3_autosar","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/AUTOSAR/01_Grundlagen/04_3_autosar.md","tags":[],"version":"current","frontMatter":{},"sidebar":"autosarSidebar","previous":{"title":"04_2_bsw-stack","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/Grundlagen/04_2_bsw-stack"},"next":{"title":"05_1_interface","permalink":"/Vehicle-Network-Standards/docs/AUTOSAR/Grundlagen/05_1_interface"}}');var t=r(74848),s=r(28453);const d={},l=void 0,a={},o=[{value:"Einleitung",id:"einleitung",level:3},{value:"\xdcberblick \xfcber das Schichtenmodell",id:"\xfcberblick-\xfcber-das-schichtenmodell",level:3},{value:"Detaillierte Analyse der Schichten",id:"detaillierte-analyse-der-schichten",level:3},{value:"Service Layer",id:"service-layer",level:4},{value:"ECU Abstraction Layer",id:"ecu-abstraction-layer",level:4},{value:"Microcontroller Abstraction Layer",id:"microcontroller-abstraction-layer",level:4},{value:"RTE (Runtime Environment)",id:"rte-runtime-environment",level:3},{value:"Zusammenfassung",id:"zusammenfassung",level:3},{value:"Weiterf\xfchrende Literatur",id:"weiterf\xfchrende-literatur",level:3}];function c(e){const n={a:"a",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h3,{id:"einleitung",children:"Einleitung"}),"\n",(0,t.jsx)(n.p,{children:"In diesem Tutorial werden wir das AUTOSAR-Schichtenmodell anhand des bereitgestellten Bildes detailliert analysieren. Das Ziel dieses Tutorials ist es, ein umfassendes Verst\xe4ndnis f\xfcr den Aufbau und die Funktion der verschiedenen Softwarekomponenten in einem AUTOSAR-konformen System zu vermitteln."}),"\n",(0,t.jsx)(n.p,{children:"AUTOSAR (AUTomotive Open System ARchitecture) ist ein Standard, der die Entwicklung und Integration von Software in Fahrzeugsteuerger\xe4ten (Electronic Control Units, ECUs) standardisiert. Dies erm\xf6glicht eine hohe Wiederverwendbarkeit von Softwaremodulen und eine vereinfachte Integration von Software von verschiedenen Lieferanten."}),"\n",(0,t.jsx)(n.h3,{id:"\xfcberblick-\xfcber-das-schichtenmodell",children:"\xdcberblick \xfcber das Schichtenmodell"}),"\n",(0,t.jsx)(n.p,{children:"Das Schichtenmodell in der Abbildung zeigt zwei ECUs: eine f\xfcr die T\xfcrsteuerung (Door ECU) und eine f\xfcr die Dachsteuerung (Roof ECU). Beide ECUs sind in Schichten unterteilt, die verschiedene Aufgaben und Verantwortlichkeiten haben. Die Schichten sind:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Service Layer"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"ECU Abstraction Layer"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Microcontroller Abstraction Layer"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"detaillierte-analyse-der-schichten",children:"Detaillierte Analyse der Schichten"}),"\n",(0,t.jsx)(n.h4,{id:"service-layer",children:"Service Layer"}),"\n",(0,t.jsx)(n.p,{children:"Der Service Layer ist f\xfcr die Bereitstellung von grundlegenden Diensten f\xfcr die Anwendung und andere BSW-Module (Basic Software) verantwortlich. In der Abbildung sind folgende Module im Service Layer zu sehen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Com (Communication Services):"})," Diese Module unterst\xfctzen die Kommunikation zwischen verschiedenen ECUs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"PduR (PDU Router):"})," Der PDU Router leitet Protokolldateneinheiten (Protocol Data Units, PDUs) zwischen verschiedenen Kommunikationsschnittstellen weiter."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"ecu-abstraction-layer",children:"ECU Abstraction Layer"}),"\n",(0,t.jsx)(n.p,{children:"Der ECU Abstraction Layer abstrahiert die hardwareabh\xe4ngigen Teile der ECU und erm\xf6glicht so eine hardwareunabh\xe4ngige Implementierung der dar\xfcber liegenden Schichten. In der Abbildung sind folgende Module im ECU Abstraction Layer zu sehen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IoHwAb (I/O Hardware Abstraction):"})," Diese Module abstrahieren die Eingabe-/Ausgabeger\xe4te der ECU."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dio (Digital Input Output):"})," Diese Module bieten eine Schnittstelle f\xfcr den Zugriff auf digitale Eingangs- und Ausgangssignale."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"CanIf (CAN Interface):"})," Dieses Modul ist f\xfcr die Abstraktion des CAN-Bus (Controller Area Network) verantwortlich und bietet eine standardisierte Schnittstelle f\xfcr die Kommunikation \xfcber den CAN-Bus."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Can (Controller Area Network):"})," Das CAN-Modul ist f\xfcr die Kommunikation \xfcber den CAN-Bus zust\xe4ndig."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"microcontroller-abstraction-layer",children:"Microcontroller Abstraction Layer"}),"\n",(0,t.jsx)(n.p,{children:"Der Microcontroller Abstraction Layer (MCAL) stellt die unterste Schicht des AUTOSAR-Schichtenmodells dar. Er bietet eine Abstraktion der Mikrocontroller-Hardware und erm\xf6glicht so eine einheitliche Schnittstelle f\xfcr die dar\xfcber liegenden Softwaremodule. Zu den in der Abbildung dargestellten Komponenten geh\xf6ren:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Microcontroller:"})," Die Hardwarebasis f\xfcr alle Operationen."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"rte-runtime-environment",children:"RTE (Runtime Environment)"}),"\n",(0,t.jsx)(n.p,{children:"Die RTE (Runtime Environment) ist eine Schl\xfcsselschicht im AUTOSAR-Architekturmodell. Sie verbindet die Anwendungskomponenten (SWCs) mit der Basissoftware (BSW) und erm\xf6glicht die Kommunikation zwischen den SWCs und der BSW ohne direkten Zugriff auf die Hardware. In der Abbildung sind die SWCs f\xfcr die T\xfcrsteuerung (Left Door, Right Door, Door Contact) und die Dachsteuerung (Dimmer, Light) durch die RTE miteinander und mit der BSW verbunden."}),"\n",(0,t.jsx)(n.h3,{id:"zusammenfassung",children:"Zusammenfassung"}),"\n",(0,t.jsx)(n.p,{children:"Das AUTOSAR-Schichtenmodell erleichtert die Entwicklung und Integration von Software in Fahrzeugsteuerger\xe4ten durch eine klare Trennung der Verantwortlichkeiten und die Bereitstellung standardisierter Schnittstellen. Dies erm\xf6glicht eine hohe Wiederverwendbarkeit von Softwaremodulen und eine vereinfachte Integration von Software von verschiedenen Lieferanten. Durch das Verst\xe4ndnis der verschiedenen Schichten und ihrer Funktionen kann man effektivere und robustere AUTOSAR-konforme Systeme entwickeln."}),"\n",(0,t.jsx)(n.p,{children:"Dieses Tutorial hat die grundlegenden Konzepte des AUTOSAR-Schichtenmodells erkl\xe4rt und sollte als Grundlage f\xfcr weiterf\xfchrende Studien und Anwendungen in der Fahrzeugsoftwareentwicklung dienen."}),"\n",(0,t.jsx)(n.h3,{id:"weiterf\xfchrende-literatur",children:"Weiterf\xfchrende Literatur"}),"\n",(0,t.jsxs)(n.p,{children:["F\xfcr tiefergehende Informationen und detaillierte Spezifikationen zu AUTOSAR empfehlen sich die offiziellen Dokumentationen und Standards, die auf der ",(0,t.jsx)(n.a,{href:"https://www.autosar.org",children:"AUTOSAR-Website"})," verf\xfcgbar sind."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>l});var i=r(96540);const t={},s=i.createContext(t);function d(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);